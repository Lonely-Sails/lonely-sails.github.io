<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Êï∞Â≠¶ÂáΩÊï∞Âä†ÂØÜÂ∑•ÂÖ∑</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        padding: 40px;
        max-width: 800px;
        width: 100%;
      }

      .title {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 28px;
        font-weight: 600;
      }

      .input-section {
        margin-bottom: 30px;
      }

      .input-label {
        display: block;
        margin-bottom: 10px;
        color: #555;
        font-weight: 500;
      }

      .input-field {
        width: 100%;
        padding: 12px 20px;
        border: 2px solid #ddd;
        border-radius: 10px;
        font-size: 16px;
        transition: border-color 0.3s ease;
        background: #f9f9f9;
      }

      .input-field:focus {
        outline: none;
        border-color: #667eea;
        background: white;
      }

      .textarea-field {
        min-height: 120px;
        resize: vertical;
        font-family: inherit;
      }

      .function-examples {
        margin-top: 8px;
        font-size: 14px;
        color: #666;
        background: #f0f4ff;
        padding: 10px;
        border-radius: 8px;
      }

      .function-examples strong {
        color: #667eea;
      }

      .action-buttons {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
      }

      .encrypt-btn,
      .decrypt-btn {
        flex: 1;
        padding: 15px;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease;
      }

      .encrypt-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .decrypt-btn {
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        color: white;
      }

      .encrypt-btn:hover,
      .decrypt-btn:hover {
        transform: translateY(-2px);
      }

      .encrypt-btn:disabled,
      .decrypt-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .result-container {
        margin-top: 20px;
      }

      .result-box {
        border: 2px solid #ddd;
        border-radius: 10px;
        padding: 20px;
        background: #f9f9f9;
        margin-bottom: 15px;
      }

      .result-label {
        font-weight: 600;
        color: #333;
        margin-bottom: 10px;
      }

      .result-content {
        font-family: "Courier New", monospace;
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
        word-break: break-all;
        white-space: pre-wrap;
        max-height: 200px;
        overflow-y: auto;
      }

      .copy-btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 10px;
        transition: background 0.3s ease;
      }

      .copy-btn:hover {
        background: #0056b3;
      }

      .copy-success {
        background: #28a745 !important;
      }

      .error-message {
        background: #f8d7da;
        color: #721c24;
        padding: 12px;
        border-radius: 8px;
        margin-top: 15px;
        border: 1px solid #f5c6cb;
      }

      .loading {
        display: none;
        text-align: center;
        color: #667eea;
        margin: 20px 0;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .steps-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }

      .function-input-wrapper {
        display: flex;
        gap: 10px;
        align-items: stretch;
      }

      .function-input-wrapper .input-field {
        flex: 1;
      }

      .edit-function-btn {
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease;
        white-space: nowrap;
      }

      .edit-function-btn:hover {
        transform: translateY(-2px);
      }

      /* ÂáΩÊï∞ÁºñËæëÂô®Ê®°ÊÄÅÊ°ÜÊ†∑Âºè */
      .function-editor-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .function-editor-content {
        background: white;
        border-radius: 20px;
        padding: 30px;
        max-width: 900px;
        width: 90%;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
      }

      .function-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .function-editor-title {
        font-size: 24px;
        font-weight: 600;
        color: #333;
      }

      .close-btn {
        background: #ff4757;
        color: white;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .close-btn:hover {
        background: #ff3742;
      }

      .function-canvas-container {
        border: 2px solid #ddd;
        border-radius: 10px;
        margin-bottom: 20px;
        background: #f9f9f9;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        overflow: hidden;
        flex: 1;
        min-height: 0;
      }

      .function-canvas {
        display: block;
        cursor: crosshair;
        border-radius: 8px;
        background: white;
        max-width: 100%;
        height: auto;
      }

      .function-info {
        background: #f0f4ff;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
      }

      .current-function {
        font-family: "Courier New", monospace;
        font-size: 18px;
        font-weight: bold;
        color: #667eea;
        margin-bottom: 10px;
      }

      .function-instructions {
        font-size: 14px;
        color: #666;
        line-height: 1.5;
      }

      .function-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .control-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .control-btn:hover {
        background: #5a6fd8;
      }

      .control-btn.danger {
        background: #ff4757;
      }

      .control-btn.danger:hover {
        background: #ff3742;
      }

      .control-btn.success {
        background: #2ed573;
      }

      .control-btn.success:hover {
        background: #26d467;
      }

      .point-info {
        position: fixed;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        pointer-events: none;
        display: none;
        z-index: 1001;
        white-space: nowrap;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }

        .action-buttons {
          flex-direction: column;
        }

        .steps-container {
          grid-template-columns: 1fr;
        }

        .function-input-wrapper {
          flex-direction: column;
        }

        .function-editor-content {
          width: 95%;
          padding: 20px;
          max-height: 95vh;
        }

        .function-controls {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="title">Êï∞Â≠¶ÂáΩÊï∞Âä†ÂØÜÂ∑•ÂÖ∑</h1>

      <div class="input-section">
        <label class="input-label">Êï∞Â≠¶ÂáΩÊï∞Ë°®ËææÂºè</label>
        <div class="function-input-wrapper">
          <input
            type="text"
            id="mathFunction"
            class="input-field"
            placeholder="‰æãÂ¶Ç: x*2+1, sin(x), x^2, etc."
          />
          <button id="editFunctionBtn" class="edit-function-btn">
            üìä ÂèØËßÜÂåñÁºñËæë
          </button>
        </div>
        <div class="function-examples">
          <strong>ÊîØÊåÅÁöÑÂáΩÊï∞:</strong> +, -, *, /, ^(ÂπÇ), sin, cos, tan, log,
          sqrt, abs, floor, ceil<br />
          <strong>Á§∫‰æã:</strong> x*2+1, sin(x*3.14/180), x^2+3*x-5, log(x+1)
        </div>
      </div>

      <div class="input-section">
        <label class="input-label">Ë¶ÅÂä†ÂØÜ/Ëß£ÂØÜÁöÑÊñáÂ≠ó</label>
        <textarea
          id="inputText"
          class="input-field textarea-field"
          placeholder="ËØ∑ËæìÂÖ•Ë¶ÅÂä†ÂØÜÊàñËß£ÂØÜÁöÑÊñáÂ≠ó..."
        ></textarea>
      </div>

      <div class="action-buttons">
        <button id="encryptBtn" class="encrypt-btn">üîí Âä†ÂØÜ</button>
        <button id="decryptBtn" class="decrypt-btn">üîì Ëß£ÂØÜ</button>
      </div>

      <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>Ê≠£Âú®Â§ÑÁêÜ...</div>
      </div>

      <div class="result-container" id="resultContainer" style="display: none">
        <div class="steps-container">
          <div class="result-box">
            <div class="result-label">Ê≠•È™§1: Base64ÁºñÁ†Å</div>
            <div class="result-content" id="base64Result"></div>
            <button class="copy-btn" onclick="copyToClipboard('base64Result')">
              Â§çÂà∂
            </button>
          </div>

          <div class="result-box">
            <div class="result-label">Ê≠•È™§2: ÂáØÊííÂä†ÂØÜÁªìÊûú</div>
            <div class="result-content" id="finalResult"></div>
            <button class="copy-btn" onclick="copyToClipboard('finalResult')">
              Â§çÂà∂
            </button>
          </div>
        </div>
      </div>

      <div id="errorMessage" class="error-message" style="display: none"></div>
    </div>

    <!-- ÂáΩÊï∞ÁºñËæëÂô®Ê®°ÊÄÅÊ°Ü -->
    <div id="functionEditorModal" class="function-editor-modal">
      <div class="function-editor-content">
        <div class="function-editor-header">
          <h2 class="function-editor-title">ÂèØËßÜÂåñÂáΩÊï∞ÁºñËæëÂô®</h2>
          <button id="closeFunctionEditor" class="close-btn">√ó</button>
        </div>

        <div class="function-info">
          <div class="current-function" id="currentFunctionDisplay">
            f(x) = x
          </div>
          <div class="function-instructions">
            <strong>‰ΩøÁî®ËØ¥ÊòéÔºö</strong><br />
            ‚Ä¢ ÁÇπÂáªÂùêÊ†áÁ≥ªÊ∑ªÂä†ÊéßÂà∂ÁÇπ<br />
            ‚Ä¢ ÊãñÊãΩÁÇπÊù•Ë∞ÉÊï¥‰ΩçÁΩÆ<br />
            ‚Ä¢ Âè≥ÈîÆÁÇπÂáªÂà†Èô§ÁÇπ<br />
            ‚Ä¢ ÂáΩÊï∞‰ºöËá™Âä®ÊãüÂêàÈÄöËøáÊâÄÊúâÁÇπ
          </div>
        </div>

        <div class="function-canvas-container">
          <canvas id="functionCanvas" class="function-canvas"></canvas>
        </div>
        <div id="pointInfo" class="point-info"></div>

        <div class="function-controls">
          <button id="clearPoints" class="control-btn danger">
            Ê∏ÖÈô§ÊâÄÊúâÁÇπ
          </button>
          <button id="resetView" class="control-btn">ÈáçÁΩÆËßÜÂõæ</button>
          <button id="applyFunction" class="control-btn success">
            Â∫îÁî®ÂáΩÊï∞
          </button>
        </div>
      </div>
    </div>

    <script>
      const mathFunctionInput = document.getElementById("mathFunction");
      const inputTextArea = document.getElementById("inputText");
      const encryptBtn = document.getElementById("encryptBtn");
      const decryptBtn = document.getElementById("decryptBtn");
      const loading = document.getElementById("loading");
      const resultContainer = document.getElementById("resultContainer");
      const base64Result = document.getElementById("base64Result");
      const finalResult = document.getElementById("finalResult");
      const errorMessage = document.getElementById("errorMessage");

      // Êï∞Â≠¶ÂáΩÊï∞Ëß£ÊûêÂô®
      function evaluateMathFunction(expression, x) {
        try {
          // Ê£ÄÊü•Ë°®ËææÂºèÊòØÂê¶‰∏∫Á©∫
          if (!expression || expression.trim() === "") {
            throw new Error(
              "Êï∞Â≠¶Ë°®ËææÂºè‰∏çËÉΩ‰∏∫Á©∫„ÄÇËØ∑ËæìÂÖ•‰∏Ä‰∏™ÊúâÊïàÁöÑÊï∞Â≠¶Ë°®ËææÂºèÔºå‰æãÂ¶ÇÔºöx*2+1 Êàñ sin(x)"
            );
          }

          // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÂèòÈáèx
          if (!expression.toLowerCase().includes("x")) {
            throw new Error(
              "Êï∞Â≠¶Ë°®ËææÂºèÂøÖÈ°ªÂåÖÂê´ÂèòÈáè x„ÄÇ‰æãÂ¶ÇÔºöx+1, x*2, sin(x) Á≠â"
            );
          }

          // ÊõøÊç¢Êï∞Â≠¶ÂáΩÊï∞
          let expr = expression
            .toLowerCase()
            .replace(/\^/g, "**") // ÂπÇËøêÁÆó
            .replace(/sin/g, "Math.sin")
            .replace(/cos/g, "Math.cos")
            .replace(/tan/g, "Math.tan")
            .replace(/log/g, "Math.log")
            .replace(/sqrt/g, "Math.sqrt")
            .replace(/abs/g, "Math.abs")
            .replace(/floor/g, "Math.floor")
            .replace(/ceil/g, "Math.ceil")
            .replace(/x/g, x.toString());

          // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂè™ÂÖÅËÆ∏Êï∞Â≠ó„ÄÅËøêÁÆóÁ¨¶ÂíåMathÂáΩÊï∞
          const allowedPattern = /^[0-9+\-*/.()Math\s]+$/;
          const cleanExpr = expr.replace(
            /Math\.(sin|cos|tan|log|sqrt|abs|floor|ceil)/g,
            ""
          );
          if (!allowedPattern.test(cleanExpr)) {
            throw new Error(
              "Êï∞Â≠¶Ë°®ËææÂºèÂåÖÂê´‰∏çÊîØÊåÅÁöÑÂ≠óÁ¨¶ÊàñÂáΩÊï∞„ÄÇ</br>ÊîØÊåÅÁöÑËøêÁÆóÁ¨¶Ôºö+ - * / ^ ( )</br>ÊîØÊåÅÁöÑÂáΩÊï∞Ôºösin cos tan log sqrt abs floor ceil</br>ËØ∑Ê£ÄÊü•ÊÇ®ÁöÑË°®ËææÂºèÊ†ºÂºè"
            );
          }

          const result = eval(expr);

          // Ê£ÄÊü•ËÆ°ÁÆóÁªìÊûúÊòØÂê¶ÊúâÊïà
          if (isNaN(result) || !isFinite(result)) {
            throw new Error(
              "Êï∞Â≠¶Ë°®ËææÂºèËÆ°ÁÆóÁªìÊûúÊó†ÊïàÔºàNaN ÊàñÊó†Á©∑Â§ßÔºâ„ÄÇ</br>ËØ∑Ê£ÄÊü•Ë°®ËææÂºèÊòØÂê¶Ê≠£Á°ÆÔºå‰æãÂ¶ÇÈÅøÂÖçÈô§Èõ∂„ÄÅË¥üÊï∞ÂºÄÊñπÁ≠âÊÉÖÂÜµ"
            );
          }

          return Math.floor(Math.abs(result)) % 26; // Á°Æ‰øùÁªìÊûúÂú®0-25‰πãÈó¥
        } catch (error) {
          if (error.message.includes("Êï∞Â≠¶Ë°®ËææÂºè")) {
            throw error; // ÈáçÊñ∞ÊäõÂá∫Êàë‰ª¨Ëá™ÂÆö‰πâÁöÑÈîôËØØ
          }
          throw new Error(
            "Êï∞Â≠¶Ë°®ËææÂºèËØ≠Ê≥ïÈîôËØØÔºö" +
              error.message +
              "</br></br>ËØ∑Ê£ÄÊü•Ôºö</br>1. Êã¨Âè∑ÊòØÂê¶ÂåπÈÖç</br>2. ËøêÁÆóÁ¨¶ÊòØÂê¶Ê≠£Á°Æ</br>3. ÂáΩÊï∞ÂêçÊòØÂê¶ÊãºÂÜôÊ≠£Á°Æ</br></br>Á§∫‰æãÔºöx*2+1, sin(x*3.14/180), sqrt(x+1)"
          );
        }
      }

      // Base64ÁºñÁ†Å
      function encodeBase64(text) {
        return btoa(unescape(encodeURIComponent(text)));
      }

      // Base64Ëß£Á†Å
      function decodeBase64(base64) {
        try {
          return decodeURIComponent(escape(atob(base64)));
        } catch (error) {
          throw new Error("Base64Ëß£Á†ÅÂ§±Ë¥•ÔºöËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤‰∏çÊòØÊúâÊïàÁöÑBase64Ê†ºÂºè");
        }
      }

      // ÂáØÊííÂä†ÂØÜ
      function caesarCipher(text, shifts) {
        return text
          .split("")
          .map((char, index) => {
            if (/[a-zA-Z]/.test(char)) {
              const shift = shifts[index % shifts.length];
              const isUpperCase = char === char.toUpperCase();
              const charCode = char.toLowerCase().charCodeAt(0) - 97;
              const shiftedCode = (charCode + shift) % 26;
              const shiftedChar = String.fromCharCode(shiftedCode + 97);
              return isUpperCase ? shiftedChar.toUpperCase() : shiftedChar;
            }
            return char;
          })
          .join("");
      }

      // ÂáØÊííËß£ÂØÜ
      function caesarDecipher(text, shifts) {
        return text
          .split("")
          .map((char, index) => {
            if (/[a-zA-Z]/.test(char)) {
              const shift = shifts[index % shifts.length];
              const isUpperCase = char === char.toUpperCase();
              const charCode = char.toLowerCase().charCodeAt(0) - 97;
              const shiftedCode = (charCode - shift + 26) % 26;
              const shiftedChar = String.fromCharCode(shiftedCode + 97);
              return isUpperCase ? shiftedChar.toUpperCase() : shiftedChar;
            }
            return char;
          })
          .join("");
      }

      // ÁîüÊàêÂÅèÁßªÈáèÊï∞ÁªÑ
      function generateShifts(mathExpression, textLength) {
        const shifts = [];
        for (let i = 0; i < textLength; i++) {
          const shift = evaluateMathFunction(mathExpression, i);
          shifts.push(shift);
        }
        return shifts;
      }

      // Âä†ÂØÜÂáΩÊï∞
      function encrypt() {
        const mathExpression = mathFunctionInput.value.trim();
        const inputText = inputTextArea.value.trim();

        if (!mathExpression) {
          showError(
            "ËØ∑ËæìÂÖ•Êï∞Â≠¶Ë°®ËææÂºè„ÄÇ</br></br>Êï∞Â≠¶Ë°®ËææÂºèÁî®‰∫éÁîüÊàêÂä†ÂØÜÂÅèÁßªÈáèÔºåÂøÖÈ°ªÂåÖÂê´ÂèòÈáè x„ÄÇ</br>Á§∫‰æãÔºöx*2+1, sin(x), x^2+3*x-5"
          );
          return;
        }

        if (!inputText) {
          showError(
            "ËØ∑ËæìÂÖ•Ë¶ÅÂä†ÂØÜÁöÑÊñáÂ≠ó„ÄÇ</br></br>ÂèØ‰ª•ËæìÂÖ•‰ªª‰ΩïÊñáÊú¨ÂÜÖÂÆπÔºåÂåÖÊã¨‰∏≠Êñá„ÄÅËã±Êñá„ÄÅÊï∞Â≠óÂíåÁâπÊÆäÂ≠óÁ¨¶„ÄÇ"
          );
          return;
        }

        try {
          showLoading(true);
          hideError();

          // Ê≠•È™§1: Base64ÁºñÁ†Å
          const base64Encoded = encodeBase64(inputText);

          // Ê≠•È™§2: ÁîüÊàêÂÅèÁßªÈáèÂπ∂ËøõË°åÂáØÊííÂä†ÂØÜ
          const shifts = generateShifts(mathExpression, base64Encoded.length);
          const encrypted = caesarCipher(base64Encoded, shifts);

          // ÊòæÁ§∫ÁªìÊûú
          base64Result.textContent = base64Encoded;
          finalResult.textContent = encrypted;

          showLoading(false);
          resultContainer.style.display = "block";
        } catch (error) {
          showLoading(false);
          showError(error.message);
        }
      }

      // Ëß£ÂØÜÂáΩÊï∞
      function decrypt() {
        const mathExpression = mathFunctionInput.value.trim();
        const inputText = inputTextArea.value.trim();

        if (!mathExpression) {
          showError(
            "ËØ∑ËæìÂÖ•Êï∞Â≠¶Ë°®ËææÂºè„ÄÇ</br></br>Ëß£ÂØÜÊó∂ÂøÖÈ°ª‰ΩøÁî®‰∏éÂä†ÂØÜÊó∂ÂÆåÂÖ®Áõ∏ÂêåÁöÑÊï∞Â≠¶Ë°®ËææÂºè„ÄÇ</br>Á§∫‰æãÔºöx*2+1, sin(x), x^2+3*x-5"
          );
          return;
        }

        if (!inputText) {
          showError(
            "ËØ∑ËæìÂÖ•Ë¶ÅËß£ÂØÜÁöÑÂØÜÊñá„ÄÇ</br></br>ÂØÜÊñáÂ∫îËØ•ÊòØÈÄöËøáÊú¨Â∑•ÂÖ∑Âä†ÂØÜÁîüÊàêÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÈÄöÂ∏∏ÂåÖÂê´Â≠óÊØçÂíåÊï∞Â≠ó„ÄÇ"
          );
          return;
        }

        // Ê£ÄÊü•ËæìÂÖ•ÊòØÂê¶ÂÉèÊòØÊúâÊïàÁöÑÂØÜÊñá
        if (!/^[A-Za-z0-9+/=]+$/.test(inputText)) {
          showError(
            "ËæìÂÖ•ÁöÑÊñáÊú¨‰∏çÂÉèÊòØÊúâÊïàÁöÑÂØÜÊñá„ÄÇ</br></br>ÊúâÊïàÁöÑÂØÜÊñáÂ∫îËØ•Âè™ÂåÖÂê´Â≠óÊØç„ÄÅÊï∞Â≠óÂíå +/= Â≠óÁ¨¶„ÄÇ</br>ËØ∑Á°ÆËÆ§ÊÇ®ËæìÂÖ•ÁöÑÊòØÈÄöËøáÊú¨Â∑•ÂÖ∑Âä†ÂØÜÁîüÊàêÁöÑÂØÜÊñá„ÄÇ"
          );
          return;
        }

        try {
          showLoading(true);
          hideError();

          // Ê≠•È™§1: ÁîüÊàêÂÅèÁßªÈáèÂπ∂ËøõË°åÂáØÊííËß£ÂØÜ
          const shifts = generateShifts(mathExpression, inputText.length);
          const decrypted = caesarDecipher(inputText, shifts);

          // Ê≠•È™§2: Base64Ëß£Á†Å
          const base64Decoded = decodeBase64(decrypted);

          // ÊòæÁ§∫ÁªìÊûú
          base64Result.textContent = decrypted;
          finalResult.textContent = base64Decoded;

          showLoading(false);
          resultContainer.style.display = "block";
        } catch (error) {
          showLoading(false);
          if (error.message.includes("Invalid character")) {
            showError(
              "Base64Ëß£Á†ÅÂ§±Ë¥•ÔºöÂØÜÊñáÊ†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ</br></br>ÂèØËÉΩÁöÑÂéüÂõ†Ôºö</br>1. ËæìÂÖ•ÁöÑ‰∏çÊòØÊúâÊïàÁöÑÂØÜÊñá</br>2. ‰ΩøÁî®‰∫ÜÈîôËØØÁöÑÊï∞Â≠¶Ë°®ËææÂºè</br>3. ÂØÜÊñáÂú®‰º†ËæìËøáÁ®ã‰∏≠Ë¢´ÊçüÂùè</br></br>ËØ∑Ê£ÄÊü•ËæìÂÖ•ÁöÑÂØÜÊñáÂíåÊï∞Â≠¶Ë°®ËææÂºèÊòØÂê¶Ê≠£Á°Æ„ÄÇ"
            );
          } else if (error.message.includes("Êï∞Â≠¶Ë°®ËææÂºè")) {
            showError(error.message);
          } else {
            showError(
              "Ëß£ÂØÜÂ§±Ë¥•Ôºö" +
                error.message +
                "</br></br>ËØ∑Á°ÆËÆ§Ôºö</br>1. Êï∞Â≠¶Ë°®ËææÂºè‰∏éÂä†ÂØÜÊó∂ÂÆåÂÖ®‰∏ÄËá¥</br>2. ÂØÜÊñáÂÆåÊï¥‰∏îÊú™Ë¢´‰øÆÊîπ</br>3. ÂØÜÊñáÊòØÈÄöËøáÊú¨Â∑•ÂÖ∑ÁîüÊàêÁöÑ"
            );
          }
        }
      }

      // Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø
      async function copyToClipboard(elementId) {
        const element = document.getElementById(elementId);
        const text = element.textContent;

        if (!text || text.trim() === "") {
          showError("Ê≤°ÊúâÂÜÖÂÆπÂèØ‰ª•Â§çÂà∂„ÄÇËØ∑ÂÖàËøõË°åÂä†ÂØÜÊàñËß£ÂØÜÊìç‰Ωú„ÄÇ");
          return;
        }

        try {
          await navigator.clipboard.writeText(text);

          // ÊâæÂà∞ÂØπÂ∫îÁöÑÂ§çÂà∂ÊåâÈíÆ
          const copyBtn = element.nextElementSibling;
          const originalText = copyBtn.textContent;
          copyBtn.textContent = "Â§çÂà∂ÊàêÂäü!";
          copyBtn.classList.add("copy-success");

          setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove("copy-success");
          }, 2000);
        } catch (err) {
          console.error("Â§çÂà∂Â§±Ë¥•:", err);
          if (err.name === "NotAllowedError") {
            showError(
              "Â§çÂà∂Â§±Ë¥•ÔºöÊµèËßàÂô®‰∏çÂÖÅËÆ∏ËÆøÈóÆÂâ™Ë¥¥Êùø„ÄÇ</br></br>Ëß£ÂÜ≥ÊñπÊ≥ïÔºö</br>1. ËØ∑ÊâãÂä®ÈÄâÊã©ÊñáÊú¨Âπ∂Êåâ Ctrl+C (Êàñ Cmd+C) Â§çÂà∂</br>2. Á°Æ‰øùÁΩëÈ°µÊòØÈÄöËøá HTTPS ËÆøÈóÆÁöÑ</br>3. Ê£ÄÊü•ÊµèËßàÂô®ÊùÉÈôêËÆæÁΩÆ"
            );
          } else {
            showError(
              "Â§çÂà∂Â§±Ë¥•Ôºö" +
                err.message +
                "</br></br>ËØ∑ÊâãÂä®ÈÄâÊã©ÊñáÊú¨Âπ∂‰ΩøÁî® Ctrl+C (Êàñ Cmd+C) Â§çÂà∂„ÄÇ"
            );
          }
        }
      }

      // ÊòæÁ§∫/ÈöêËóèÂä†ËΩΩÁä∂ÊÄÅ
      function showLoading(show) {
        loading.style.display = show ? "block" : "none";
        encryptBtn.disabled = show;
        decryptBtn.disabled = show;
      }

      // ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
      function showError(message) {
        errorMessage.innerHTML = message;
        errorMessage.style.display = "block";
        resultContainer.style.display = "none";
      }

      // ÈöêËóèÈîôËØØ‰ø°ÊÅØ
      function hideError() {
        errorMessage.style.display = "none";
      }

      // ‰∫ã‰ª∂ÁõëÂê¨
      encryptBtn.addEventListener("click", encrypt);
      decryptBtn.addEventListener("click", decrypt);

      // ËæìÂÖ•Êó∂ÈöêËóèÈîôËØØ‰ø°ÊÅØ
      mathFunctionInput.addEventListener("input", hideError);
      inputTextArea.addEventListener("input", hideError);

      // ÂáΩÊï∞ÁºñËæëÂô®Áõ∏ÂÖ≥ÂèòÈáèÂíåÂáΩÊï∞
      const editFunctionBtn = document.getElementById("editFunctionBtn");
      const functionEditorModal = document.getElementById(
        "functionEditorModal"
      );
      const closeFunctionEditor = document.getElementById(
        "closeFunctionEditor"
      );
      const functionCanvas = document.getElementById("functionCanvas");
      const ctx = functionCanvas.getContext("2d");
      const currentFunctionDisplay = document.getElementById(
        "currentFunctionDisplay"
      );
      const clearPointsBtn = document.getElementById("clearPoints");
      const resetViewBtn = document.getElementById("resetView");
      const applyFunctionBtn = document.getElementById("applyFunction");
      const pointInfo = document.getElementById("pointInfo");

      let points = [];
      let draggedPoint = null;
      let canvasRect = null;
      let currentFunction = "x";

      // ÂùêÊ†áÁ≥ªÂèÇÊï∞
      let canvasWidth = 800;
      let canvasHeight = 400;
      let centerX = canvasWidth / 2;
      let centerY = canvasHeight / 2;
      const scale = 6; // ÊØèÂçï‰ΩçÁöÑÂÉèÁ¥†Êï∞ (30/5 = 6ÔºåËøôÊ†∑5‰∏™Âçï‰ΩçÂç†30ÂÉèÁ¥†)
      const gridSize = 5; // ÁΩëÊ†ºÈó¥Ë∑ùÊîπ‰∏∫5‰∏™Âçï‰Ωç

      // ËÆæÁΩÆÈ´òDPIÁîªÂ∏É
      function setupCanvas() {
        const container = functionCanvas.parentElement;
        const containerWidth = container.clientWidth - 20; // ÂáèÂéªpadding
        const containerHeight = Math.min(400, containerWidth * 0.5); // ‰øùÊåÅÊØî‰æã

        // ËÆæÁΩÆÊòæÁ§∫Â∞∫ÂØ∏
        functionCanvas.style.width = containerWidth + "px";
        functionCanvas.style.height = containerHeight + "px";

        // Ëé∑ÂèñËÆæÂ§áÂÉèÁ¥†ÊØî
        const dpr = window.devicePixelRatio || 1;

        // ËÆæÁΩÆÂÆûÈôÖÁîªÂ∏ÉÂ∞∫ÂØ∏
        canvasWidth = containerWidth * dpr;
        canvasHeight = containerHeight * dpr;
        functionCanvas.width = canvasWidth;
        functionCanvas.height = canvasHeight;

        // Áº©Êîæ‰∏ä‰∏ãÊñá‰ª•ÂåπÈÖçËÆæÂ§áÂÉèÁ¥†ÊØî
        ctx.scale(dpr, dpr);

        // Êõ¥Êñ∞‰∏≠ÂøÉÁÇπ
        centerX = containerWidth / 2;
        centerY = containerHeight / 2;
      }

      // ÊâìÂºÄÂáΩÊï∞ÁºñËæëÂô®
      function openFunctionEditor() {
        functionEditorModal.style.display = "flex";
        setupCanvas();
        drawCanvas();
      }

      // ÂÖ≥Èó≠ÂáΩÊï∞ÁºñËæëÂô®
      function closeFunctionEditorModal() {
        functionEditorModal.style.display = "none";
      }

      // ÁªòÂà∂ÁîªÂ∏É
      function drawCanvas() {
        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.clearRect(0, 0, displayWidth, displayHeight);

        // ÁªòÂà∂ÁΩëÊ†º
        drawGrid();

        // ÁªòÂà∂ÂùêÊ†áËΩ¥
        drawAxes();

        // ÁªòÂà∂ÂΩìÂâçÂáΩÊï∞Êõ≤Á∫ø
        drawFunctionCurve();

        // ÁªòÂà∂ÊéßÂà∂ÁÇπ
        drawPoints();
      }

      // ÁªòÂà∂ÁΩëÊ†º
      function drawGrid() {
        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 0.5;

        // ÂûÇÁõ¥ÁΩëÊ†ºÁ∫ø
        for (
          let x = centerX % (scale * gridSize);
          x < displayWidth;
          x += scale * gridSize
        ) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, displayHeight);
          ctx.stroke();
        }

        // Ê∞¥Âπ≥ÁΩëÊ†ºÁ∫ø
        for (
          let y = centerY % (scale * gridSize);
          y < displayHeight;
          y += scale * gridSize
        ) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(displayWidth, y);
          ctx.stroke();
        }
      }

      // ÁªòÂà∂ÂùêÊ†áËΩ¥
      function drawAxes() {
        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;

        // XËΩ¥
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(displayWidth, centerY);
        ctx.stroke();

        // YËΩ¥
        ctx.beginPath();
        ctx.moveTo(centerX, 0);
        ctx.lineTo(centerX, displayHeight);
        ctx.stroke();

        // ÁªòÂà∂ÂàªÂ∫¶
        ctx.fillStyle = "#666";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";

        // XËΩ¥ÂàªÂ∫¶ - Âè™ÊòæÁ§∫5ÁöÑÂÄçÊï∞
        for (
          let i = -Math.floor(centerX / scale);
          i <= Math.floor((displayWidth - centerX) / scale);
          i++
        ) {
          if (i !== 0 && i % 5 === 0) {
            const x = centerX + i * scale;
            ctx.fillText(i.toString(), x, centerY + 15);
          }
        }

        // YËΩ¥ÂàªÂ∫¶ - Âè™ÊòæÁ§∫5ÁöÑÂÄçÊï∞
        ctx.textAlign = "right";
        for (
          let i = -Math.floor((displayHeight - centerY) / scale);
          i <= Math.floor(centerY / scale);
          i++
        ) {
          if (i !== 0 && i % 5 === 0) {
            const y = centerY - i * scale;
            ctx.fillText(i.toString(), centerX - 5, y + 4);
          }
        }
      }

      // ÁªòÂà∂ÂáΩÊï∞Êõ≤Á∫ø
      function drawFunctionCurve() {
        if (points.length === 0) return;

        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.strokeStyle = "#667eea";
        ctx.lineWidth = 3;
        ctx.beginPath();

        let firstPoint = true;
        let lastValidY = null;

        for (let pixelX = 0; pixelX < displayWidth; pixelX += 2) {
          const mathX = (pixelX - centerX) / scale;
          const mathY = evaluateCurrentFunction(mathX);

          if (isFinite(mathY)) {
            const pixelY = centerY - mathY * scale;

            // ÈôêÂà∂YÂÄºÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖÔºåÈÅøÂÖçÊûÅÁ´ØÊåØËç°
            const clampedPixelY = Math.max(
              -displayHeight,
              Math.min(displayHeight * 2, pixelY)
            );

            if (firstPoint) {
              ctx.moveTo(pixelX, clampedPixelY);
              firstPoint = false;
            } else {
              // Â¶ÇÊûúYÂÄºÂèòÂåñÂ§™ÂâßÁÉàÔºåÊñ≠ÂºÄËøûÁ∫ø
              if (
                lastValidY !== null &&
                Math.abs(clampedPixelY - lastValidY) > displayHeight
              ) {
                ctx.moveTo(pixelX, clampedPixelY);
              } else {
                ctx.lineTo(pixelX, clampedPixelY);
              }
            }
            lastValidY = clampedPixelY;
          }
        }

        ctx.stroke();
      }

      // ÁªòÂà∂ÊéßÂà∂ÁÇπ
      function drawPoints() {
        points.forEach((point, index) => {
          const pixelX = centerX + point.x * scale;
          const pixelY = centerY - point.y * scale;

          // ÁªòÂà∂ÁÇπ
          ctx.fillStyle = "#ff4757";
          ctx.beginPath();
          ctx.arc(pixelX, pixelY, 6, 0, 2 * Math.PI);
          ctx.fill();

          // ÁªòÂà∂ËæπÊ°Ü
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();

          // ÁªòÂà∂ÂùêÊ†áÊ†áÁ≠æ
          ctx.fillStyle = "#333";
          ctx.font = "11px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            `(${point.x.toFixed(0)}, ${point.y.toFixed(0)})`,
            pixelX,
            pixelY - 10
          );
        });
      }

      // ËÆ°ÁÆóÂΩìÂâçÂáΩÊï∞ÂÄº
      function evaluateCurrentFunction(x) {
        if (points.length === 0) return x;
        if (points.length === 1) return points[0].y;

        try {
          // ÂØπ‰∫é2‰∏™ÁÇπÔºå‰ΩøÁî®Á∫øÊÄßÊèíÂÄº
          if (points.length === 2) {
            const p1 = points[0];
            const p2 = points[1];
            if (Math.abs(p1.x - p2.x) < 0.001) return p1.y;
            const slope = (p2.y - p1.y) / (p2.x - p1.x);
            return p1.y + slope * (x - p1.x);
          }

          // ÂØπ‰∫é3‰∏™ÁÇπÔºå‰ΩøÁî®‰∫åÊ¨°ÊèíÂÄº
          if (points.length === 3) {
            const sortedPoints = [...points].sort((a, b) => a.x - b.x);
            const [p1, p2, p3] = sortedPoints;

            const denom = (p1.x - p2.x) * (p1.x - p3.x) * (p2.x - p3.x);
            if (Math.abs(denom) < 0.001) return points[0].y;

            const a =
              (p3.x * (p2.y - p1.y) +
                p2.x * (p1.y - p3.y) +
                p1.x * (p3.y - p2.y)) /
              denom;
            const b =
              (p3.x * p3.x * (p1.y - p2.y) +
                p2.x * p2.x * (p3.y - p1.y) +
                p1.x * p1.x * (p2.y - p3.y)) /
              denom;
            const c =
              (p2.x * p3.x * (p2.x - p3.x) * p1.y +
                p3.x * p1.x * (p3.x - p1.x) * p2.y +
                p1.x * p2.x * (p1.x - p2.x) * p3.y) /
              denom;

            return a * x * x + b * x + c;
          }

          // ÂØπ‰∫éÊõ¥Â§öÁÇπÔºå‰ΩøÁî®ÈôêÂà∂ËåÉÂõ¥ÁöÑÊãâÊ†ºÊúóÊó•ÊèíÂÄº
          let result = 0;
          for (let i = 0; i < points.length; i++) {
            let term = points[i].y;
            let denomProduct = 1;

            for (let j = 0; j < points.length; j++) {
              if (i !== j) {
                const denomFactor = points[i].x - points[j].x;
                if (Math.abs(denomFactor) < 0.001) return points[i].y; // ÈÅøÂÖçÈô§Èõ∂
                denomProduct *= denomFactor;
                term *= x - points[j].x;
              }
            }

            if (Math.abs(denomProduct) > 0.001) {
              term /= denomProduct;
              result += term;
            }
          }

          // ÈôêÂà∂ÁªìÊûúËåÉÂõ¥ÔºåÈÅøÂÖçÊûÅÁ´ØÂÄº
          const minY = Math.min(...points.map((p) => p.y));
          const maxY = Math.max(...points.map((p) => p.y));
          const range = maxY - minY;
          const clampedResult = Math.max(
            minY - range * 2,
            Math.min(maxY + range * 2, result)
          );

          return clampedResult;
        } catch (error) {
          return points[0]?.y || 0;
        }
      }

      // ÁîüÊàêÂáΩÊï∞Ë°®ËææÂºè
      function generateFunctionExpression() {
        if (points.length === 0) {
          return "x";
        }

        if (points.length === 1) {
          return points[0].y.toFixed(2);
        }

        if (points.length === 2) {
          const p1 = points[0];
          const p2 = points[1];

          if (Math.abs(p1.x - p2.x) < 0.001) {
            return points[0].y.toFixed(2); // ÂûÇÁõ¥Á∫øÔºåËøîÂõûÂ∏∏Êï∞
          }

          const slope = (p2.y - p1.y) / (p2.x - p1.x);
          const intercept = p1.y - slope * p1.x;

          if (Math.abs(intercept) < 0.01) {
            return `${slope.toFixed(2)}*x`;
          } else if (intercept > 0) {
            return `${slope.toFixed(2)}*x+${intercept.toFixed(2)}`;
          } else {
            return `${slope.toFixed(2)}*x${intercept.toFixed(2)}`;
          }
        }

        // ÂØπ‰∫é3‰∏™ÁÇπÔºåÊãüÂêà‰∫åÊ¨°ÂáΩÊï∞
        if (points.length === 3) {
          return fitPolynomial();
        }

        // ÂØπ‰∫éÊõ¥Â§öÁÇπÔºåÂ∞ùËØïÊãüÂêàÁÆÄÂçïÁöÑÂ§öÈ°πÂºèÊàñÊòæÁ§∫Ëøë‰ººË°®ËææÂºè
        if (points.length >= 4) {
          return generateApproximateExpression();
        }

        return "x"; // ÈªòËÆ§ËøîÂõû
      }

      // ÊãüÂêàÂ§öÈ°πÂºè
      function fitPolynomial() {
        const sortedPoints = [...points].sort((a, b) => a.x - b.x);

        // Â∞ùËØï‰∫åÊ¨°ÂáΩÊï∞ÊãüÂêà
        if (sortedPoints.length === 3) {
          const [p1, p2, p3] = sortedPoints;

          // Ëß£‰∫åÊ¨°ÊñπÁ®ãÁªÑ ax¬≤ + bx + c = y
          const x1 = p1.x,
            y1 = p1.y;
          const x2 = p2.x,
            y2 = p2.y;
          const x3 = p3.x,
            y3 = p3.y;

          const denom = (x1 - x2) * (x1 - x3) * (x2 - x3);
          if (Math.abs(denom) < 0.001) return "x";

          const a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;
          const b =
            (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) /
            denom;
          const c =
            (x2 * x3 * (x2 - x3) * y1 +
              x3 * x1 * (x3 - x1) * y2 +
              x1 * x2 * (x1 - x2) * y3) /
            denom;

          let expr = "";
          if (Math.abs(a) > 0.01) {
            expr += `${a.toFixed(2)}*x^2`;
          }
          if (Math.abs(b) > 0.01) {
            if (expr && b > 0) expr += "+";
            expr += `${b.toFixed(2)}*x`;
          }
          if (Math.abs(c) > 0.01) {
            if (expr && c > 0) expr += "+";
            expr += c.toFixed(2);
          }

          return expr || "0";
        }

        return "x";
      }

      // ÁîüÊàêËøë‰ººË°®ËææÂºèÔºàÁî®‰∫é4‰∏™ÊàñÊõ¥Â§öÁÇπÔºâ
      function generateApproximateExpression() {
        const sortedPoints = [...points].sort((a, b) => a.x - b.x);

        // Â∞ùËØïÊ£ÄÊµãÂáΩÊï∞Á±ªÂûã
        const xValues = sortedPoints.map((p) => p.x);
        const yValues = sortedPoints.map((p) => p.y);

        // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÁ∫øÊÄß
        if (isApproximatelyLinear(sortedPoints)) {
          const firstPoint = sortedPoints[0];
          const lastPoint = sortedPoints[sortedPoints.length - 1];
          const slope =
            (lastPoint.y - firstPoint.y) / (lastPoint.x - firstPoint.x);
          const intercept = firstPoint.y - slope * firstPoint.x;

          if (Math.abs(intercept) < 0.01) {
            return `${slope.toFixed(2)}*x`;
          } else if (intercept > 0) {
            return `${slope.toFixed(2)}*x+${intercept.toFixed(2)}`;
          } else {
            return `${slope.toFixed(2)}*x${intercept.toFixed(2)}`;
          }
        }

        // Ê£ÄÊü•ÊòØÂê¶Êé•Ëøë‰∫åÊ¨°ÂáΩÊï∞
        if (
          sortedPoints.length >= 4 &&
          isApproximatelyQuadratic(sortedPoints)
        ) {
          const quadratic = fitQuadraticApprox(sortedPoints);
          return quadratic;
        }

        // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÊ≠£Âº¶ÂáΩÊï∞
        if (isApproximatelySinusoidal(sortedPoints)) {
          const sinParams = fitSinusoidal(sortedPoints);
          return sinParams;
        }

        // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÊåáÊï∞ÂáΩÊï∞
        if (isApproximatelyExponential(sortedPoints)) {
          return "ÊåáÊï∞ÂáΩÊï∞Ëøë‰ºº";
        }

        // ÈªòËÆ§ËÆ°ÁÆóÊãâÊ†ºÊúóÊó•ÊèíÂÄºÂ§öÈ°πÂºè
        return calculateLagrangePolynomial();
      }

      // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÁ∫øÊÄß
      function isApproximatelyLinear(points) {
        if (points.length < 3) return true;

        const firstPoint = points[0];
        const lastPoint = points[points.length - 1];
        const expectedSlope =
          (lastPoint.y - firstPoint.y) / (lastPoint.x - firstPoint.x);

        let maxDeviation = 0;
        for (let i = 1; i < points.length - 1; i++) {
          const expectedY =
            firstPoint.y + expectedSlope * (points[i].x - firstPoint.x);
          const deviation = Math.abs(points[i].y - expectedY);
          maxDeviation = Math.max(maxDeviation, deviation);
        }

        const range = Math.abs(lastPoint.y - firstPoint.y);
        return maxDeviation < Math.max(0.5, range * 0.1);
      }

      // Ê£ÄÊü•ÊòØÂê¶Êé•Ëøë‰∫åÊ¨°ÂáΩÊï∞
      function isApproximatelyQuadratic(points) {
        if (points.length < 4) return false;

        // ‰ΩøÁî®Ââç‰∏â‰∏™ÁÇπÊãüÂêà‰∫åÊ¨°ÂáΩÊï∞ÔºåÊ£ÄÊü•ÂÖ∂‰ªñÁÇπÁöÑÂÅèÂ∑Æ
        const [p1, p2, p3] = points.slice(0, 3);

        const denom = (p1.x - p2.x) * (p1.x - p3.x) * (p2.x - p3.x);
        if (Math.abs(denom) < 0.001) return false;

        const a =
          (p3.x * (p2.y - p1.y) + p2.x * (p1.y - p3.y) + p1.x * (p3.y - p2.y)) /
          denom;
        const b =
          (p3.x * p3.x * (p1.y - p2.y) +
            p2.x * p2.x * (p3.y - p1.y) +
            p1.x * p1.x * (p2.y - p3.y)) /
          denom;
        const c =
          (p2.x * p3.x * (p2.x - p3.x) * p1.y +
            p3.x * p1.x * (p3.x - p1.x) * p2.y +
            p1.x * p2.x * (p1.x - p2.x) * p3.y) /
          denom;

        let maxDeviation = 0;
        for (let i = 3; i < points.length; i++) {
          const x = points[i].x;
          const expectedY = a * x * x + b * x + c;
          const deviation = Math.abs(points[i].y - expectedY);
          maxDeviation = Math.max(maxDeviation, deviation);
        }

        const yRange =
          Math.max(...points.map((p) => p.y)) -
          Math.min(...points.map((p) => p.y));
        return maxDeviation < Math.max(0.5, yRange * 0.15);
      }

      // ÊãüÂêà‰∫åÊ¨°ÂáΩÊï∞Ëøë‰ºº
      function fitQuadraticApprox(points) {
        const [p1, p2, p3] = points.slice(0, 3);

        const denom = (p1.x - p2.x) * (p1.x - p3.x) * (p2.x - p3.x);
        if (Math.abs(denom) < 0.001) return "x";

        const a =
          (p3.x * (p2.y - p1.y) + p2.x * (p1.y - p3.y) + p1.x * (p3.y - p2.y)) /
          denom;
        const b =
          (p3.x * p3.x * (p1.y - p2.y) +
            p2.x * p2.x * (p3.y - p1.y) +
            p1.x * p1.x * (p2.y - p3.y)) /
          denom;
        const c =
          (p2.x * p3.x * (p2.x - p3.x) * p1.y +
            p3.x * p1.x * (p3.x - p1.x) * p2.y +
            p1.x * p2.x * (p1.x - p2.x) * p3.y) /
          denom;

        let expr = "";
        if (Math.abs(a) > 0.01) {
          expr += `${a.toFixed(2)}*x^2`;
        }
        if (Math.abs(b) > 0.01) {
          if (expr && b > 0) expr += "+";
          expr += `${b.toFixed(2)}*x`;
        }
        if (Math.abs(c) > 0.01) {
          if (expr && c > 0) expr += "+";
          expr += c.toFixed(2);
        }

        return expr || "0";
      }

      // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÊ≠£Âº¶ÂáΩÊï∞
      function isApproximatelySinusoidal(points) {
        if (points.length < 6) return false;

        // ÁÆÄÂçïÊ£ÄÊü•ÔºöÁúãÊòØÂê¶ÊúâÂë®ÊúüÊÄßÊåØËç°
        const yValues = points.map((p) => p.y);
        const yMean = yValues.reduce((a, b) => a + b) / yValues.length;

        let crossings = 0;
        let lastSign = yValues[0] > yMean ? 1 : -1;

        for (let i = 1; i < yValues.length; i++) {
          const currentSign = yValues[i] > yMean ? 1 : -1;
          if (currentSign !== lastSign) {
            crossings++;
            lastSign = currentSign;
          }
        }

        return crossings >= 4; // Ëá≥Â∞ë2‰∏™ÂÆåÊï¥Âë®Êúü
      }

      // ÊãüÂêàÊ≠£Âº¶ÂáΩÊï∞
      function fitSinusoidal(points) {
        const yValues = points.map((p) => p.y);
        const amplitude = (Math.max(...yValues) - Math.min(...yValues)) / 2;
        const offset = (Math.max(...yValues) + Math.min(...yValues)) / 2;

        // ‰º∞ÁÆóÈ¢ëÁéáÔºàÁÆÄÂåñÔºâ
        const xRange = points[points.length - 1].x - points[0].x;
        const frequency = (2 * Math.PI) / (xRange / 2); // ÂÅáËÆæ2‰∏™Âë®Êúü

        if (Math.abs(offset) < 0.01) {
          return `${amplitude.toFixed(2)}*sin(${frequency.toFixed(2)}*x)`;
        } else if (offset > 0) {
          return `${amplitude.toFixed(2)}*sin(${frequency.toFixed(
            2
          )}*x)+${offset.toFixed(2)}`;
        } else {
          return `${amplitude.toFixed(2)}*sin(${frequency.toFixed(
            2
          )}*x)${offset.toFixed(2)}`;
        }
      }

      // Ê£ÄÊü•ÊòØÂê¶Êé•ËøëÊåáÊï∞ÂáΩÊï∞
      function isApproximatelyExponential(points) {
        if (points.length < 4) return false;

        // Ê£ÄÊü•yÂÄºÊòØÂê¶ÂëàÊåáÊï∞Â¢ûÈïøÊàñË°∞Âáè
        const yValues = points.map((p) => p.y);
        if (yValues.some((y) => y <= 0)) return false; // ÊåáÊï∞ÂáΩÊï∞ÂøÖÈ°ª‰∏∫Ê≠£

        const logYValues = yValues.map((y) => Math.log(y));
        return isApproximatelyLinear(
          points.map((p, i) => ({ x: p.x, y: logYValues[i] }))
        );
      }

      // ËÆ°ÁÆóÊãâÊ†ºÊúóÊó•ÊèíÂÄºÂ§öÈ°πÂºèÁöÑÂÖ∑‰ΩìË°®ËææÂºè
      function calculateLagrangePolynomial() {
        if (points.length === 0) return "x";
        if (points.length === 1) return points[0].y.toFixed(2);

        // ÂàùÂßãÂåñÂ§öÈ°πÂºèÁ≥ªÊï∞Êï∞ÁªÑ (‰ªéÂ∏∏Êï∞È°πÂà∞ÊúÄÈ´òÊ¨°È°π)
        const degree = points.length - 1;
        const coefficients = new Array(degree + 1).fill(0);

        // ÂØπÊØè‰∏™ÁÇπËÆ°ÁÆóÂÖ∂ÊãâÊ†ºÊúóÊó•Âü∫ÂáΩÊï∞ÁöÑË¥°ÁåÆ
        for (let i = 0; i < points.length; i++) {
          const xi = points[i].x;
          const yi = points[i].y;

          // ËÆ°ÁÆóÁ¨¨i‰∏™ÊãâÊ†ºÊúóÊó•Âü∫ÂáΩÊï∞ Li(x)
          const baseCoeffs = calculateLagrangeBasis(i);

          // Â∞Ü yi * Li(x) Âä†Âà∞ÊÄªÂ§öÈ°πÂºè‰∏≠
          for (let j = 0; j < baseCoeffs.length; j++) {
            coefficients[j] += yi * baseCoeffs[j];
          }
        }

        // Ê†ºÂºèÂåñÂ§öÈ°πÂºèË°®ËææÂºè
        return formatPolynomialFromCoeffs(coefficients);
      }

      // ËÆ°ÁÆóÁ¨¨i‰∏™ÊãâÊ†ºÊúóÊó•Âü∫ÂáΩÊï∞ÁöÑÁ≥ªÊï∞
      function calculateLagrangeBasis(i) {
        const xi = points[i].x;
        const degree = points.length - 1;

        // ÂºÄÂßãÊó∂Âü∫ÂáΩÊï∞ÊòØÂ∏∏Êï∞1
        let coeffs = [1]; // Ë°®Á§∫Â§öÈ°πÂºè 1

        // ÈÄê‰∏™‰πò‰ª• (x - xj) / (xi - xj) ÂÖ∂‰∏≠ j != i
        for (let j = 0; j < points.length; j++) {
          if (i !== j) {
            const xj = points[j].x;
            const denominator = xi - xj;

            if (Math.abs(denominator) < 1e-10) continue; // ÈÅøÂÖçÈô§Èõ∂

            // Â∞ÜÂΩìÂâçÂ§öÈ°πÂºè‰πò‰ª• (x - xj) / (xi - xj)
            coeffs = multiplyPolynomial(coeffs, [
              -xj / denominator,
              1 / denominator,
            ]);
          }
        }

        // Á°Æ‰øùÁ≥ªÊï∞Êï∞ÁªÑÈïøÂ∫¶Ê≠£Á°Æ
        while (coeffs.length <= degree) {
          coeffs.push(0);
        }

        return coeffs;
      }

      // Â§öÈ°πÂºè‰πòÊ≥ïÔºöÂ∞Ü‰∏§‰∏™Â§öÈ°πÂºèÁõ∏‰πò
      function multiplyPolynomial(poly1, poly2) {
        const result = new Array(poly1.length + poly2.length - 1).fill(0);

        for (let i = 0; i < poly1.length; i++) {
          for (let j = 0; j < poly2.length; j++) {
            result[i + j] += poly1[i] * poly2[j];
          }
        }

        return result;
      }

      // Ê†ºÂºèÂåñÂ§öÈ°πÂºèÁ≥ªÊï∞‰∏∫Ë°®ËææÂºè
      function formatPolynomialFromCoeffs(coeffs) {
        let expr = "";

        // ‰ªéÊúÄÈ´òÊ¨°È°πÂºÄÂßã
        for (let i = coeffs.length - 1; i >= 0; i--) {
          const coeff = coeffs[i];

          // Ë∑≥ËøáÊé•ËøëÈõ∂ÁöÑÁ≥ªÊï∞
          if (Math.abs(coeff) < 0.001) continue;

          // Ê∑ªÂä†Á¨¶Âè∑
          if (expr.length > 0) {
            expr += coeff > 0 ? "+" : "";
          }

          // Ê†ºÂºèÂåñÁ≥ªÊï∞ÂíåÂèòÈáè
          if (i === 0) {
            // Â∏∏Êï∞È°π
            expr += coeff.toFixed(2);
          } else if (i === 1) {
            // ‰∏ÄÊ¨°È°π
            if (Math.abs(coeff - 1) < 0.001) {
              expr += "x";
            } else if (Math.abs(coeff + 1) < 0.001) {
              expr += "-x";
            } else {
              expr += `${coeff.toFixed(2)}*x`;
            }
          } else {
            // È´òÊ¨°È°π
            if (Math.abs(coeff - 1) < 0.001) {
              expr += `x^${i}`;
            } else if (Math.abs(coeff + 1) < 0.001) {
              expr += `-x^${i}`;
            } else {
              expr += `${coeff.toFixed(2)}*x^${i}`;
            }
          }
        }

        return expr || "0";
      }

      // Êõ¥Êñ∞ÂáΩÊï∞ÊòæÁ§∫
      function updateFunctionDisplay() {
        currentFunction = generateFunctionExpression();
        currentFunctionDisplay.textContent = `f(x) = ${currentFunction}`;
      }

      // ÂÉèÁ¥†ÂùêÊ†áËΩ¨Êï∞Â≠¶ÂùêÊ†á
      function pixelToMath(pixelX, pixelY) {
        return {
          x: (pixelX - centerX) / scale,
          y: (centerY - pixelY) / scale,
        };
      }

      // Êï∞Â≠¶ÂùêÊ†áËΩ¨ÂÉèÁ¥†ÂùêÊ†á
      function mathToPixel(mathX, mathY) {
        return {
          x: centerX + mathX * scale,
          y: centerY - mathY * scale,
        };
      }

      // Êü•ÊâæÁÇπÂáªÁöÑÁÇπ
      function findPointAt(pixelX, pixelY) {
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          const pixel = mathToPixel(point.x, point.y);
          const distance = Math.sqrt(
            (pixelX - pixel.x) ** 2 + (pixelY - pixel.y) ** 2
          );
          if (distance <= 8) {
            return i;
          }
        }
        return -1;
      }

      // ÁîªÂ∏É‰∫ã‰ª∂Â§ÑÁêÜ
      functionCanvas.addEventListener("mousedown", (e) => {
        const rect = functionCanvas.getBoundingClientRect();
        const pixelX = e.clientX - rect.left;
        const pixelY = e.clientY - rect.top;

        const pointIndex = findPointAt(pixelX, pixelY);

        if (e.button === 2) {
          // Âè≥ÈîÆÂà†Èô§ÁÇπ
          if (pointIndex !== -1) {
            points.splice(pointIndex, 1);
            updateFunctionDisplay();
            drawCanvas();
          }
          e.preventDefault();
          return;
        }

        if (pointIndex !== -1) {
          // ÂºÄÂßãÊãñÊãΩ
          draggedPoint = pointIndex;
        } else {
          // Ê∑ªÂä†Êñ∞ÁÇπ
          const mathCoord = pixelToMath(pixelX, pixelY);
          points.push({
            x: Math.round(mathCoord.x),
            y: Math.round(mathCoord.y),
          });
          updateFunctionDisplay();
          drawCanvas();
        }
      });

      functionCanvas.addEventListener("mousemove", (e) => {
        const rect = functionCanvas.getBoundingClientRect();
        const pixelX = e.clientX - rect.left;
        const pixelY = e.clientY - rect.top;

        if (draggedPoint !== null) {
          const mathCoord = pixelToMath(pixelX, pixelY);
          points[draggedPoint] = {
            x: Math.round(mathCoord.x),
            y: Math.round(mathCoord.y),
          };
          updateFunctionDisplay();
          drawCanvas();
        }

        // ÊòæÁ§∫ÂùêÊ†á‰ø°ÊÅØ
        const mathCoord = pixelToMath(pixelX, pixelY);
        pointInfo.textContent = `(${mathCoord.x.toFixed(
          0
        )}, ${mathCoord.y.toFixed(0)})`;
        pointInfo.style.left = e.clientX + 10 + "px";
        pointInfo.style.top = e.clientY - 30 + "px";
        pointInfo.style.display = "block";
      });

      functionCanvas.addEventListener("mouseup", () => {
        draggedPoint = null;
      });

      functionCanvas.addEventListener("mouseleave", () => {
        draggedPoint = null;
        pointInfo.style.display = "none";
      });

      functionCanvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      // ÊéßÂà∂ÊåâÈíÆ‰∫ã‰ª∂
      clearPointsBtn.addEventListener("click", () => {
        points = [];
        updateFunctionDisplay();
        drawCanvas();
      });

      resetViewBtn.addEventListener("click", () => {
        points = [];
        currentFunction = "x";
        updateFunctionDisplay();
        drawCanvas();
      });

      applyFunctionBtn.addEventListener("click", () => {
        mathFunctionInput.value = currentFunction;
        closeFunctionEditorModal();
      });

      // ÁºñËæëÂô®‰∫ã‰ª∂ÁõëÂê¨
      editFunctionBtn.addEventListener("click", openFunctionEditor);
      closeFunctionEditor.addEventListener("click", closeFunctionEditorModal);

      // ÁÇπÂáªÊ®°ÊÄÅÊ°ÜËÉåÊôØÂÖ≥Èó≠
      functionEditorModal.addEventListener("click", (e) => {
        if (e.target === functionEditorModal) {
          closeFunctionEditorModal();
        }
      });
    </script>
  </body>
</html>
