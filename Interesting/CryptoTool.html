<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ•°å­¦å‡½æ•°åŠ å¯†å·¥å…·</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        padding: 40px;
        max-width: 800px;
        width: 100%;
      }

      .title {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 28px;
        font-weight: 600;
      }

      .input-section {
        margin-bottom: 30px;
      }

      .input-label {
        display: block;
        margin-bottom: 10px;
        color: #555;
        font-weight: 500;
      }

      .input-field {
        width: 100%;
        padding: 12px 20px;
        border: 2px solid #ddd;
        border-radius: 10px;
        font-size: 16px;
        transition: border-color 0.3s ease;
        background: #f9f9f9;
      }

      .input-field:focus {
        outline: none;
        border-color: #667eea;
        background: white;
      }

      .textarea-field {
        min-height: 120px;
        resize: vertical;
        font-family: inherit;
      }

      .function-examples {
        margin-top: 8px;
        font-size: 14px;
        color: #666;
        background: #f0f4ff;
        padding: 10px;
        border-radius: 8px;
      }

      .function-examples strong {
        color: #667eea;
      }

      .action-buttons {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
      }

      .encrypt-btn,
      .decrypt-btn {
        flex: 1;
        padding: 15px;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease;
      }

      .encrypt-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .decrypt-btn {
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        color: white;
      }

      .encrypt-btn:hover,
      .decrypt-btn:hover {
        transform: translateY(-2px);
      }

      .encrypt-btn:disabled,
      .decrypt-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .result-container {
        margin-top: 20px;
      }

      .result-box {
        border: 2px solid #ddd;
        border-radius: 10px;
        padding: 20px;
        background: #f9f9f9;
        margin-bottom: 15px;
      }

      .result-label {
        font-weight: 600;
        color: #333;
        margin-bottom: 10px;
      }

      .result-content {
        font-family: "Courier New", monospace;
        background: white;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
        word-break: break-all;
        white-space: pre-wrap;
        max-height: 200px;
        overflow-y: auto;
      }

      .copy-btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        margin-top: 10px;
        transition: background 0.3s ease;
      }

      .copy-btn:hover {
        background: #0056b3;
      }

      .copy-success {
        background: #28a745 !important;
      }

      .error-message {
        background: #f8d7da;
        color: #721c24;
        padding: 12px;
        border-radius: 8px;
        margin-top: 15px;
        border: 1px solid #f5c6cb;
      }

      .loading {
        display: none;
        text-align: center;
        color: #667eea;
        margin: 20px 0;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .steps-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }

      .function-input-wrapper {
        display: flex;
        gap: 10px;
        align-items: stretch;
      }

      .function-input-wrapper .input-field {
        flex: 1;
      }

      .edit-function-btn {
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease;
        white-space: nowrap;
      }

      .edit-function-btn:hover {
        transform: translateY(-2px);
      }

      /* å‡½æ•°ç¼–è¾‘å™¨æ¨¡æ€æ¡†æ ·å¼ */
      .function-editor-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .function-editor-content {
        background: white;
        border-radius: 20px;
        padding: 30px;
        max-width: 900px;
        width: 90%;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
      }

      .function-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .function-editor-title {
        font-size: 24px;
        font-weight: 600;
        color: #333;
      }

      .close-btn {
        background: #ff4757;
        color: white;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .close-btn:hover {
        background: #ff3742;
      }

      .function-canvas-container {
        border: 2px solid #ddd;
        border-radius: 10px;
        margin-bottom: 20px;
        background: #f9f9f9;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        overflow: hidden;
        flex: 1;
        min-height: 0;
      }

      .function-canvas {
        display: block;
        cursor: crosshair;
        border-radius: 8px;
        background: white;
        max-width: 100%;
        height: auto;
      }

      .function-info {
        background: #f0f4ff;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
      }

      .current-function {
        font-family: "Courier New", monospace;
        font-size: 18px;
        font-weight: bold;
        color: #667eea;
        margin-bottom: 10px;
      }

      .function-instructions {
        font-size: 14px;
        color: #666;
        line-height: 1.5;
      }

      .function-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .control-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .control-btn:hover {
        background: #5a6fd8;
      }

      .control-btn.danger {
        background: #ff4757;
      }

      .control-btn.danger:hover {
        background: #ff3742;
      }

      .control-btn.success {
        background: #2ed573;
      }

      .control-btn.success:hover {
        background: #26d467;
      }

      .point-info {
        position: fixed;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        pointer-events: none;
        display: none;
        z-index: 1001;
        white-space: nowrap;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }

        .action-buttons {
          flex-direction: column;
        }

        .steps-container {
          grid-template-columns: 1fr;
        }

        .function-input-wrapper {
          flex-direction: column;
        }

        .function-editor-content {
          width: 95%;
          padding: 20px;
          max-height: 95vh;
        }

        .function-controls {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="title">æ•°å­¦å‡½æ•°åŠ å¯†å·¥å…·</h1>

      <div class="input-section">
        <label class="input-label">æ•°å­¦å‡½æ•°è¡¨è¾¾å¼</label>
        <div class="function-input-wrapper">
          <input
            type="text"
            id="mathFunction"
            class="input-field"
            placeholder="ä¾‹å¦‚: x*2+1, sin(x), x^2, etc."
          />
          <button id="editFunctionBtn" class="edit-function-btn">
            ğŸ“Š å¯è§†åŒ–ç¼–è¾‘
          </button>
        </div>
        <div class="function-examples">
          <strong>æ”¯æŒçš„å‡½æ•°:</strong> +, -, *, /, ^(å¹‚), sin, cos, tan, log,
          sqrt, abs, floor, ceil<br />
          <strong>ç¤ºä¾‹:</strong> x*2+1, sin(x*3.14/180), x^2+3*x-5, log(x+1)
        </div>
      </div>

      <div class="input-section">
        <label class="input-label">è¦åŠ å¯†/è§£å¯†çš„æ–‡å­—</label>
        <textarea
          id="inputText"
          class="input-field textarea-field"
          placeholder="è¯·è¾“å…¥è¦åŠ å¯†æˆ–è§£å¯†çš„æ–‡å­—..."
        ></textarea>
      </div>

      <div class="action-buttons">
        <button id="encryptBtn" class="encrypt-btn">ğŸ”’ åŠ å¯†</button>
        <button id="decryptBtn" class="decrypt-btn">ğŸ”“ è§£å¯†</button>
      </div>

      <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨å¤„ç†...</div>
      </div>

      <div class="result-container" id="resultContainer" style="display: none">
        <div class="steps-container">
          <div class="result-box">
            <div class="result-label">æ­¥éª¤1: Base64ç¼–ç </div>
            <div class="result-content" id="base64Result"></div>
            <button class="copy-btn" onclick="copyToClipboard('base64Result')">
              å¤åˆ¶
            </button>
          </div>

          <div class="result-box">
            <div class="result-label">æ­¥éª¤2: å‡¯æ’’åŠ å¯†ç»“æœ</div>
            <div class="result-content" id="finalResult"></div>
            <button class="copy-btn" onclick="copyToClipboard('finalResult')">
              å¤åˆ¶
            </button>
          </div>
        </div>
      </div>

      <div id="errorMessage" class="error-message" style="display: none"></div>
    </div>

    <!-- å‡½æ•°ç¼–è¾‘å™¨æ¨¡æ€æ¡† -->
    <div id="functionEditorModal" class="function-editor-modal">
      <div class="function-editor-content">
        <div class="function-editor-header">
          <h2 class="function-editor-title">å¯è§†åŒ–å‡½æ•°ç¼–è¾‘å™¨</h2>
          <button id="closeFunctionEditor" class="close-btn">Ã—</button>
        </div>

        <div class="function-info">
          <div class="current-function" id="currentFunctionDisplay">
            f(x) = x
          </div>
          <div class="function-instructions">
            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br />
            â€¢ ç‚¹å‡»åæ ‡ç³»æ·»åŠ æ§åˆ¶ç‚¹<br />
            â€¢ æ‹–æ‹½ç‚¹æ¥è°ƒæ•´ä½ç½®<br />
            â€¢ å³é”®ç‚¹å‡»åˆ é™¤ç‚¹<br />
            â€¢ å‡½æ•°ä¼šè‡ªåŠ¨æ‹Ÿåˆé€šè¿‡æ‰€æœ‰ç‚¹
          </div>
        </div>

        <div class="function-canvas-container">
          <canvas id="functionCanvas" class="function-canvas"></canvas>
        </div>
        <div id="pointInfo" class="point-info"></div>

        <div class="function-controls">
          <button id="clearPoints" class="control-btn danger">
            æ¸…é™¤æ‰€æœ‰ç‚¹
          </button>
          <button id="resetView" class="control-btn">é‡ç½®è§†å›¾</button>
          <button id="applyFunction" class="control-btn success">
            åº”ç”¨å‡½æ•°
          </button>
        </div>
      </div>
    </div>

    <script>
      const mathFunctionInput = document.getElementById("mathFunction");
      const inputTextArea = document.getElementById("inputText");
      const encryptBtn = document.getElementById("encryptBtn");
      const decryptBtn = document.getElementById("decryptBtn");
      const loading = document.getElementById("loading");
      const resultContainer = document.getElementById("resultContainer");
      const base64Result = document.getElementById("base64Result");
      const finalResult = document.getElementById("finalResult");
      const errorMessage = document.getElementById("errorMessage");

      // æ•°å­¦å‡½æ•°è§£æå™¨
      function evaluateMathFunction(expression, x) {
        try {
          // æ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦ä¸ºç©º
          if (!expression || expression.trim() === "") {
            throw new Error(
              "æ•°å­¦è¡¨è¾¾å¼ä¸èƒ½ä¸ºç©ºã€‚è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­¦è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼šx*2+1 æˆ– sin(x)"
            );
          }

          // æ£€æŸ¥æ˜¯å¦åŒ…å«å˜é‡x
          if (!expression.toLowerCase().includes("x")) {
            throw new Error(
              "æ•°å­¦è¡¨è¾¾å¼å¿…é¡»åŒ…å«å˜é‡ xã€‚ä¾‹å¦‚ï¼šx+1, x*2, sin(x) ç­‰"
            );
          }

          // æ›¿æ¢æ•°å­¦å‡½æ•°
          let expr = expression
            .toLowerCase()
            .replace(/\^/g, "**") // å¹‚è¿ç®—
            .replace(/sin/g, "Math.sin")
            .replace(/cos/g, "Math.cos")
            .replace(/tan/g, "Math.tan")
            .replace(/log/g, "Math.log")
            .replace(/sqrt/g, "Math.sqrt")
            .replace(/abs/g, "Math.abs")
            .replace(/floor/g, "Math.floor")
            .replace(/ceil/g, "Math.ceil")
            .replace(/x/g, x.toString());

          // å®‰å…¨æ£€æŸ¥ï¼šåªå…è®¸æ•°å­—ã€è¿ç®—ç¬¦å’ŒMathå‡½æ•°
          const allowedPattern = /^[0-9+\-*/.()Math\s]+$/;
          const cleanExpr = expr.replace(
            /Math\.(sin|cos|tan|log|sqrt|abs|floor|ceil)/g,
            ""
          );
          if (!allowedPattern.test(cleanExpr)) {
            throw new Error(
              "æ•°å­¦è¡¨è¾¾å¼åŒ…å«ä¸æ”¯æŒçš„å­—ç¬¦æˆ–å‡½æ•°ã€‚</br>æ”¯æŒçš„è¿ç®—ç¬¦ï¼š+ - * / ^ ( )</br>æ”¯æŒçš„å‡½æ•°ï¼šsin cos tan log sqrt abs floor ceil</br>è¯·æ£€æŸ¥æ‚¨çš„è¡¨è¾¾å¼æ ¼å¼"
            );
          }

          const result = eval(expr);

          // æ£€æŸ¥è®¡ç®—ç»“æœæ˜¯å¦æœ‰æ•ˆ
          if (isNaN(result) || !isFinite(result)) {
            throw new Error(
              "æ•°å­¦è¡¨è¾¾å¼è®¡ç®—ç»“æœæ— æ•ˆï¼ˆNaN æˆ–æ— ç©·å¤§ï¼‰ã€‚</br>è¯·æ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦æ­£ç¡®ï¼Œä¾‹å¦‚é¿å…é™¤é›¶ã€è´Ÿæ•°å¼€æ–¹ç­‰æƒ…å†µ"
            );
          }

          return Math.floor(Math.abs(result)) % 26; // ç¡®ä¿ç»“æœåœ¨0-25ä¹‹é—´
        } catch (error) {
          if (error.message.includes("æ•°å­¦è¡¨è¾¾å¼")) {
            throw error; // é‡æ–°æŠ›å‡ºæˆ‘ä»¬è‡ªå®šä¹‰çš„é”™è¯¯
          }
          throw new Error(
            "æ•°å­¦è¡¨è¾¾å¼è¯­æ³•é”™è¯¯ï¼š" +
              error.message +
              "</br></br>è¯·æ£€æŸ¥ï¼š</br>1. æ‹¬å·æ˜¯å¦åŒ¹é…</br>2. è¿ç®—ç¬¦æ˜¯å¦æ­£ç¡®</br>3. å‡½æ•°åæ˜¯å¦æ‹¼å†™æ­£ç¡®</br></br>ç¤ºä¾‹ï¼šx*2+1, sin(x*3.14/180), sqrt(x+1)"
          );
        }
      }

      // Base64ç¼–ç 
      function encodeBase64(text) {
        return btoa(unescape(encodeURIComponent(text)));
      }

      // Base64è§£ç 
      function decodeBase64(base64) {
        try {
          return decodeURIComponent(escape(atob(base64)));
        } catch (error) {
          throw new Error("Base64è§£ç å¤±è´¥ï¼šè¾“å…¥çš„å­—ç¬¦ä¸²ä¸æ˜¯æœ‰æ•ˆçš„Base64æ ¼å¼");
        }
      }

      // å‡¯æ’’åŠ å¯†
      function caesarCipher(text, shifts) {
        return text
          .split("")
          .map((char, index) => {
            if (/[a-zA-Z]/.test(char)) {
              const shift = shifts[index % shifts.length];
              const isUpperCase = char === char.toUpperCase();
              const charCode = char.toLowerCase().charCodeAt(0) - 97;
              const shiftedCode = (charCode + shift) % 26;
              const shiftedChar = String.fromCharCode(shiftedCode + 97);
              return isUpperCase ? shiftedChar.toUpperCase() : shiftedChar;
            }
            return char;
          })
          .join("");
      }

      // å‡¯æ’’è§£å¯†
      function caesarDecipher(text, shifts) {
        return text
          .split("")
          .map((char, index) => {
            if (/[a-zA-Z]/.test(char)) {
              const shift = shifts[index % shifts.length];
              const isUpperCase = char === char.toUpperCase();
              const charCode = char.toLowerCase().charCodeAt(0) - 97;
              const shiftedCode = (charCode - shift + 26) % 26;
              const shiftedChar = String.fromCharCode(shiftedCode + 97);
              return isUpperCase ? shiftedChar.toUpperCase() : shiftedChar;
            }
            return char;
          })
          .join("");
      }

      // ç”Ÿæˆåç§»é‡æ•°ç»„
      function generateShifts(mathExpression, textLength) {
        const shifts = [];
        for (let i = 0; i < textLength; i++) {
          const shift = evaluateMathFunction(mathExpression, i);
          shifts.push(shift);
        }
        return shifts;
      }

      // åŠ å¯†å‡½æ•°
      function encrypt() {
        const mathExpression = mathFunctionInput.value.trim();
        const inputText = inputTextArea.value.trim();

        if (!mathExpression) {
          showError(
            "è¯·è¾“å…¥æ•°å­¦è¡¨è¾¾å¼ã€‚</br></br>æ•°å­¦è¡¨è¾¾å¼ç”¨äºç”ŸæˆåŠ å¯†åç§»é‡ï¼Œå¿…é¡»åŒ…å«å˜é‡ xã€‚</br>ç¤ºä¾‹ï¼šx*2+1, sin(x), x^2+3*x-5"
          );
          return;
        }

        if (!inputText) {
          showError(
            "è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡å­—ã€‚</br></br>å¯ä»¥è¾“å…¥ä»»ä½•æ–‡æœ¬å†…å®¹ï¼ŒåŒ…æ‹¬ä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—å’Œç‰¹æ®Šå­—ç¬¦ã€‚"
          );
          return;
        }

        try {
          showLoading(true);
          hideError();

          // æ­¥éª¤1: Base64ç¼–ç 
          const base64Encoded = encodeBase64(inputText);

          // æ­¥éª¤2: ç”Ÿæˆåç§»é‡å¹¶è¿›è¡Œå‡¯æ’’åŠ å¯†
          const shifts = generateShifts(mathExpression, base64Encoded.length);
          const encrypted = caesarCipher(base64Encoded, shifts);

          // æ˜¾ç¤ºç»“æœ
          base64Result.textContent = base64Encoded;
          finalResult.textContent = encrypted;

          showLoading(false);
          resultContainer.style.display = "block";
        } catch (error) {
          showLoading(false);
          showError(error.message);
        }
      }

      // è§£å¯†å‡½æ•°
      function decrypt() {
        const mathExpression = mathFunctionInput.value.trim();
        const inputText = inputTextArea.value.trim();

        if (!mathExpression) {
          showError(
            "è¯·è¾“å…¥æ•°å­¦è¡¨è¾¾å¼ã€‚</br></br>è§£å¯†æ—¶å¿…é¡»ä½¿ç”¨ä¸åŠ å¯†æ—¶å®Œå…¨ç›¸åŒçš„æ•°å­¦è¡¨è¾¾å¼ã€‚</br>ç¤ºä¾‹ï¼šx*2+1, sin(x), x^2+3*x-5"
          );
          return;
        }

        if (!inputText) {
          showError(
            "è¯·è¾“å…¥è¦è§£å¯†çš„å¯†æ–‡ã€‚</br></br>å¯†æ–‡åº”è¯¥æ˜¯é€šè¿‡æœ¬å·¥å…·åŠ å¯†ç”Ÿæˆçš„å­—ç¬¦ä¸²ï¼Œé€šå¸¸åŒ…å«å­—æ¯å’Œæ•°å­—ã€‚"
          );
          return;
        }

        // æ£€æŸ¥è¾“å…¥æ˜¯å¦åƒæ˜¯æœ‰æ•ˆçš„å¯†æ–‡
        if (!/^[A-Za-z0-9+/=]+$/.test(inputText)) {
          showError(
            "è¾“å…¥çš„æ–‡æœ¬ä¸åƒæ˜¯æœ‰æ•ˆçš„å¯†æ–‡ã€‚</br></br>æœ‰æ•ˆçš„å¯†æ–‡åº”è¯¥åªåŒ…å«å­—æ¯ã€æ•°å­—å’Œ +/= å­—ç¬¦ã€‚</br>è¯·ç¡®è®¤æ‚¨è¾“å…¥çš„æ˜¯é€šè¿‡æœ¬å·¥å…·åŠ å¯†ç”Ÿæˆçš„å¯†æ–‡ã€‚"
          );
          return;
        }

        try {
          showLoading(true);
          hideError();

          // æ­¥éª¤1: ç”Ÿæˆåç§»é‡å¹¶è¿›è¡Œå‡¯æ’’è§£å¯†
          const shifts = generateShifts(mathExpression, inputText.length);
          const decrypted = caesarDecipher(inputText, shifts);

          // æ­¥éª¤2: Base64è§£ç 
          const base64Decoded = decodeBase64(decrypted);

          // æ˜¾ç¤ºç»“æœ
          base64Result.textContent = decrypted;
          finalResult.textContent = base64Decoded;

          showLoading(false);
          resultContainer.style.display = "block";
        } catch (error) {
          showLoading(false);
          if (error.message.includes("Invalid character")) {
            showError(
              "Base64è§£ç å¤±è´¥ï¼šå¯†æ–‡æ ¼å¼ä¸æ­£ç¡®ã€‚</br></br>å¯èƒ½çš„åŸå› ï¼š</br>1. è¾“å…¥çš„ä¸æ˜¯æœ‰æ•ˆçš„å¯†æ–‡</br>2. ä½¿ç”¨äº†é”™è¯¯çš„æ•°å­¦è¡¨è¾¾å¼</br>3. å¯†æ–‡åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«æŸå</br></br>è¯·æ£€æŸ¥è¾“å…¥çš„å¯†æ–‡å’Œæ•°å­¦è¡¨è¾¾å¼æ˜¯å¦æ­£ç¡®ã€‚"
            );
          } else if (error.message.includes("æ•°å­¦è¡¨è¾¾å¼")) {
            showError(error.message);
          } else {
            showError(
              "è§£å¯†å¤±è´¥ï¼š" +
                error.message +
                "</br></br>è¯·ç¡®è®¤ï¼š</br>1. æ•°å­¦è¡¨è¾¾å¼ä¸åŠ å¯†æ—¶å®Œå…¨ä¸€è‡´</br>2. å¯†æ–‡å®Œæ•´ä¸”æœªè¢«ä¿®æ”¹</br>3. å¯†æ–‡æ˜¯é€šè¿‡æœ¬å·¥å…·ç”Ÿæˆçš„"
            );
          }
        }
      }

      // å¤åˆ¶åˆ°å‰ªè´´æ¿
      async function copyToClipboard(elementId) {
        const element = document.getElementById(elementId);
        const text = element.textContent;

        if (!text || text.trim() === "") {
          showError("æ²¡æœ‰å†…å®¹å¯ä»¥å¤åˆ¶ã€‚è¯·å…ˆè¿›è¡ŒåŠ å¯†æˆ–è§£å¯†æ“ä½œã€‚");
          return;
        }

        try {
          await navigator.clipboard.writeText(text);

          // æ‰¾åˆ°å¯¹åº”çš„å¤åˆ¶æŒ‰é’®
          const copyBtn = element.nextElementSibling;
          const originalText = copyBtn.textContent;
          copyBtn.textContent = "å¤åˆ¶æˆåŠŸ!";
          copyBtn.classList.add("copy-success");

          setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove("copy-success");
          }, 2000);
        } catch (err) {
          console.error("å¤åˆ¶å¤±è´¥:", err);
          if (err.name === "NotAllowedError") {
            showError(
              "å¤åˆ¶å¤±è´¥ï¼šæµè§ˆå™¨ä¸å…è®¸è®¿é—®å‰ªè´´æ¿ã€‚</br></br>è§£å†³æ–¹æ³•ï¼š</br>1. è¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¹¶æŒ‰ Ctrl+C (æˆ– Cmd+C) å¤åˆ¶</br>2. ç¡®ä¿ç½‘é¡µæ˜¯é€šè¿‡ HTTPS è®¿é—®çš„</br>3. æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®"
            );
          } else {
            showError(
              "å¤åˆ¶å¤±è´¥ï¼š" +
                err.message +
                "</br></br>è¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¹¶ä½¿ç”¨ Ctrl+C (æˆ– Cmd+C) å¤åˆ¶ã€‚"
            );
          }
        }
      }

      // æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
      function showLoading(show) {
        loading.style.display = show ? "block" : "none";
        encryptBtn.disabled = show;
        decryptBtn.disabled = show;
      }

      // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
      function showError(message) {
        errorMessage.innerHTML = message;
        errorMessage.style.display = "block";
        resultContainer.style.display = "none";
      }

      // éšè—é”™è¯¯ä¿¡æ¯
      function hideError() {
        errorMessage.style.display = "none";
      }

      // äº‹ä»¶ç›‘å¬
      encryptBtn.addEventListener("click", encrypt);
      decryptBtn.addEventListener("click", decrypt);

      // è¾“å…¥æ—¶éšè—é”™è¯¯ä¿¡æ¯
      mathFunctionInput.addEventListener("input", hideError);
      inputTextArea.addEventListener("input", hideError);

      // å‡½æ•°ç¼–è¾‘å™¨ç›¸å…³å˜é‡å’Œå‡½æ•°
      const editFunctionBtn = document.getElementById("editFunctionBtn");
      const functionEditorModal = document.getElementById(
        "functionEditorModal"
      );
      const closeFunctionEditor = document.getElementById(
        "closeFunctionEditor"
      );
      const functionCanvas = document.getElementById("functionCanvas");
      const ctx = functionCanvas.getContext("2d");
      const currentFunctionDisplay = document.getElementById(
        "currentFunctionDisplay"
      );
      const clearPointsBtn = document.getElementById("clearPoints");
      const resetViewBtn = document.getElementById("resetView");
      const applyFunctionBtn = document.getElementById("applyFunction");
      const pointInfo = document.getElementById("pointInfo");

      let points = [];
      let draggedPoint = null;
      let canvasRect = null;
      let currentFunction = "x";

      // åæ ‡ç³»å‚æ•°
      let canvasWidth = 800;
      let canvasHeight = 400;
      let centerX = canvasWidth / 2;
      let centerY = canvasHeight / 2;
      const scale = 6; // æ¯å•ä½çš„åƒç´ æ•° (30/5 = 6ï¼Œè¿™æ ·5ä¸ªå•ä½å 30åƒç´ )
      const gridSize = 5; // ç½‘æ ¼é—´è·æ”¹ä¸º5ä¸ªå•ä½

      // è®¾ç½®é«˜DPIç”»å¸ƒ
      function setupCanvas() {
        const container = functionCanvas.parentElement;
        const containerWidth = container.clientWidth - 20; // å‡å»padding
        const containerHeight = Math.min(400, containerWidth * 0.5); // ä¿æŒæ¯”ä¾‹

        // è®¾ç½®æ˜¾ç¤ºå°ºå¯¸
        functionCanvas.style.width = containerWidth + "px";
        functionCanvas.style.height = containerHeight + "px";

        // è·å–è®¾å¤‡åƒç´ æ¯”
        const dpr = window.devicePixelRatio || 1;

        // è®¾ç½®å®é™…ç”»å¸ƒå°ºå¯¸
        canvasWidth = containerWidth * dpr;
        canvasHeight = containerHeight * dpr;
        functionCanvas.width = canvasWidth;
        functionCanvas.height = canvasHeight;

        // ç¼©æ”¾ä¸Šä¸‹æ–‡ä»¥åŒ¹é…è®¾å¤‡åƒç´ æ¯”
        ctx.scale(dpr, dpr);

        // æ›´æ–°ä¸­å¿ƒç‚¹
        centerX = containerWidth / 2;
        centerY = containerHeight / 2;
      }

      // æ‰“å¼€å‡½æ•°ç¼–è¾‘å™¨
      function openFunctionEditor() {
        functionEditorModal.style.display = "flex";
        setupCanvas();
        drawCanvas();
      }

      // å…³é—­å‡½æ•°ç¼–è¾‘å™¨
      function closeFunctionEditorModal() {
        functionEditorModal.style.display = "none";
      }

      // ç»˜åˆ¶ç”»å¸ƒ
      function drawCanvas() {
        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.clearRect(0, 0, displayWidth, displayHeight);

        // ç»˜åˆ¶ç½‘æ ¼
        drawGrid();

        // ç»˜åˆ¶åæ ‡è½´
        drawAxes();

        // ç»˜åˆ¶å½“å‰å‡½æ•°æ›²çº¿
        drawFunctionCurve();

        // ç»˜åˆ¶æ§åˆ¶ç‚¹
        drawPoints();
      }

      // ç»˜åˆ¶ç½‘æ ¼
      function drawGrid() {
        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.strokeStyle = "#e0e0e0";
        ctx.lineWidth = 0.5;

        // å‚ç›´ç½‘æ ¼çº¿
        for (
          let x = centerX % (scale * gridSize);
          x < displayWidth;
          x += scale * gridSize
        ) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, displayHeight);
          ctx.stroke();
        }

        // æ°´å¹³ç½‘æ ¼çº¿
        for (
          let y = centerY % (scale * gridSize);
          y < displayHeight;
          y += scale * gridSize
        ) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(displayWidth, y);
          ctx.stroke();
        }
      }

      // ç»˜åˆ¶åæ ‡è½´
      function drawAxes() {
        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;

        // Xè½´
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(displayWidth, centerY);
        ctx.stroke();

        // Yè½´
        ctx.beginPath();
        ctx.moveTo(centerX, 0);
        ctx.lineTo(centerX, displayHeight);
        ctx.stroke();

        // ç»˜åˆ¶åˆ»åº¦
        ctx.fillStyle = "#666";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";

        // Xè½´åˆ»åº¦ - åªæ˜¾ç¤º5çš„å€æ•°
        for (
          let i = -Math.floor(centerX / scale);
          i <= Math.floor((displayWidth - centerX) / scale);
          i++
        ) {
          if (i !== 0 && i % 5 === 0) {
            const x = centerX + i * scale;
            ctx.fillText(i.toString(), x, centerY + 15);
          }
        }

        // Yè½´åˆ»åº¦ - åªæ˜¾ç¤º5çš„å€æ•°
        ctx.textAlign = "right";
        for (
          let i = -Math.floor((displayHeight - centerY) / scale);
          i <= Math.floor(centerY / scale);
          i++
        ) {
          if (i !== 0 && i % 5 === 0) {
            const y = centerY - i * scale;
            ctx.fillText(i.toString(), centerX - 5, y + 4);
          }
        }
      }

      // ç»˜åˆ¶å‡½æ•°æ›²çº¿
      function drawFunctionCurve() {
        if (points.length === 0) return;

        const displayWidth = functionCanvas.clientWidth;
        const displayHeight = functionCanvas.clientHeight;

        ctx.strokeStyle = "#667eea";
        ctx.lineWidth = 3;
        ctx.beginPath();

        let firstPoint = true;
        let lastValidY = null;

        for (let pixelX = 0; pixelX < displayWidth; pixelX += 2) {
          const mathX = (pixelX - centerX) / scale;
          const mathY = evaluateCurrentFunction(mathX);

          if (isFinite(mathY)) {
            const pixelY = centerY - mathY * scale;

            // é™åˆ¶Yå€¼åœ¨åˆç†èŒƒå›´å†…ï¼Œé¿å…æç«¯æŒ¯è¡
            const clampedPixelY = Math.max(
              -displayHeight,
              Math.min(displayHeight * 2, pixelY)
            );

            if (firstPoint) {
              ctx.moveTo(pixelX, clampedPixelY);
              firstPoint = false;
            } else {
              // å¦‚æœYå€¼å˜åŒ–å¤ªå‰§çƒˆï¼Œæ–­å¼€è¿çº¿
              if (
                lastValidY !== null &&
                Math.abs(clampedPixelY - lastValidY) > displayHeight
              ) {
                ctx.moveTo(pixelX, clampedPixelY);
              } else {
                ctx.lineTo(pixelX, clampedPixelY);
              }
            }
            lastValidY = clampedPixelY;
          }
        }

        ctx.stroke();
      }

      // ç»˜åˆ¶æ§åˆ¶ç‚¹
      function drawPoints() {
        points.forEach((point, index) => {
          const pixelX = centerX + point.x * scale;
          const pixelY = centerY - point.y * scale;

          // ç»˜åˆ¶ç‚¹
          ctx.fillStyle = "#ff4757";
          ctx.beginPath();
          ctx.arc(pixelX, pixelY, 6, 0, 2 * Math.PI);
          ctx.fill();

          // ç»˜åˆ¶è¾¹æ¡†
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();

          // ç»˜åˆ¶åæ ‡æ ‡ç­¾
          ctx.fillStyle = "#333";
          ctx.font = "11px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            `(${point.x.toFixed(0)}, ${point.y.toFixed(0)})`,
            pixelX,
            pixelY - 10
          );
        });
      }

      // è®¡ç®—å½“å‰å‡½æ•°å€¼
      function evaluateCurrentFunction(x) {
        if (points.length === 0) return x;
        if (points.length === 1) return points[0].y;

        try {
          // å¯¹äº2ä¸ªç‚¹ï¼Œä½¿ç”¨çº¿æ€§æ’å€¼
          if (points.length === 2) {
            const p1 = points[0];
            const p2 = points[1];
            if (Math.abs(p1.x - p2.x) < 0.001) return p1.y;
            const slope = (p2.y - p1.y) / (p2.x - p1.x);
            return p1.y + slope * (x - p1.x);
          }

          // å¯¹äº3ä¸ªç‚¹ï¼Œä½¿ç”¨äºŒæ¬¡æ’å€¼
          if (points.length === 3) {
            const sortedPoints = [...points].sort((a, b) => a.x - b.x);
            const [p1, p2, p3] = sortedPoints;

            const denom = (p1.x - p2.x) * (p1.x - p3.x) * (p2.x - p3.x);
            if (Math.abs(denom) < 0.001) return points[0].y;

            const a =
              (p3.x * (p2.y - p1.y) +
                p2.x * (p1.y - p3.y) +
                p1.x * (p3.y - p2.y)) /
              denom;
            const b =
              (p3.x * p3.x * (p1.y - p2.y) +
                p2.x * p2.x * (p3.y - p1.y) +
                p1.x * p1.x * (p2.y - p3.y)) /
              denom;
            const c =
              (p2.x * p3.x * (p2.x - p3.x) * p1.y +
                p3.x * p1.x * (p3.x - p1.x) * p2.y +
                p1.x * p2.x * (p1.x - p2.x) * p3.y) /
              denom;

            return a * x * x + b * x + c;
          }

          // å¯¹äºæ›´å¤šç‚¹ï¼Œä½¿ç”¨é™åˆ¶èŒƒå›´çš„æ‹‰æ ¼æœ—æ—¥æ’å€¼
          let result = 0;
          for (let i = 0; i < points.length; i++) {
            let term = points[i].y;
            let denomProduct = 1;

            for (let j = 0; j < points.length; j++) {
              if (i !== j) {
                const denomFactor = points[i].x - points[j].x;
                if (Math.abs(denomFactor) < 0.001) return points[i].y; // é¿å…é™¤é›¶
                denomProduct *= denomFactor;
                term *= x - points[j].x;
              }
            }

            if (Math.abs(denomProduct) > 0.001) {
              term /= denomProduct;
              result += term;
            }
          }

          // é™åˆ¶ç»“æœèŒƒå›´ï¼Œé¿å…æç«¯å€¼
          const minY = Math.min(...points.map((p) => p.y));
          const maxY = Math.max(...points.map((p) => p.y));
          const range = maxY - minY;
          const clampedResult = Math.max(
            minY - range * 2,
            Math.min(maxY + range * 2, result)
          );

          return clampedResult;
        } catch (error) {
          return points[0]?.y || 0;
        }
      }

      // ç”Ÿæˆå‡½æ•°è¡¨è¾¾å¼
      function generateFunctionExpression() {
        if (points.length === 0) {
          return "x";
        }

        if (points.length === 1) {
          return points[0].y.toFixed(2);
        }

        if (points.length === 2) {
          const p1 = points[0];
          const p2 = points[1];

          if (Math.abs(p1.x - p2.x) < 0.001) {
            return points[0].y.toFixed(2); // å‚ç›´çº¿ï¼Œè¿”å›å¸¸æ•°
          }

          const slope = (p2.y - p1.y) / (p2.x - p1.x);
          const intercept = p1.y - slope * p1.x;

          if (Math.abs(intercept) < 0.01) {
            return `${slope.toFixed(2)}*x`;
          } else if (intercept > 0) {
            return `${slope.toFixed(2)}*x+${intercept.toFixed(2)}`;
          } else {
            return `${slope.toFixed(2)}*x${intercept.toFixed(2)}`;
          }
        }

        // å¯¹äº3ä¸ªç‚¹ï¼Œæ‹ŸåˆäºŒæ¬¡å‡½æ•°
        if (points.length === 3) {
          return fitPolynomial();
        }

        // å¯¹äºæ›´å¤šç‚¹ï¼Œå°è¯•æ‹Ÿåˆç®€å•çš„å¤šé¡¹å¼æˆ–æ˜¾ç¤ºè¿‘ä¼¼è¡¨è¾¾å¼
        if (points.length >= 4) {
          return generateApproximateExpression();
        }

        return "x"; // é»˜è®¤è¿”å›
      }

      // æ‹Ÿåˆå¤šé¡¹å¼
      function fitPolynomial() {
        const sortedPoints = [...points].sort((a, b) => a.x - b.x);

        // å°è¯•äºŒæ¬¡å‡½æ•°æ‹Ÿåˆ
        if (sortedPoints.length === 3) {
          const [p1, p2, p3] = sortedPoints;

          // è§£äºŒæ¬¡æ–¹ç¨‹ç»„ axÂ² + bx + c = y
          const x1 = p1.x,
            y1 = p1.y;
          const x2 = p2.x,
            y2 = p2.y;
          const x3 = p3.x,
            y3 = p3.y;

          const denom = (x1 - x2) * (x1 - x3) * (x2 - x3);
          if (Math.abs(denom) < 0.001) return "x";

          const a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;
          const b =
            (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) /
            denom;
          const c =
            (x2 * x3 * (x2 - x3) * y1 +
              x3 * x1 * (x3 - x1) * y2 +
              x1 * x2 * (x1 - x2) * y3) /
            denom;

          let expr = "";
          if (Math.abs(a) > 0.01) {
            expr += `${a.toFixed(2)}*x^2`;
          }
          if (Math.abs(b) > 0.01) {
            if (expr && b > 0) expr += "+";
            expr += `${b.toFixed(2)}*x`;
          }
          if (Math.abs(c) > 0.01) {
            if (expr && c > 0) expr += "+";
            expr += c.toFixed(2);
          }

          return expr || "0";
        }

        return "x";
      }

      // ç”Ÿæˆè¿‘ä¼¼è¡¨è¾¾å¼ï¼ˆç”¨äº4ä¸ªæˆ–æ›´å¤šç‚¹ï¼‰
      function generateApproximateExpression() {
        const sortedPoints = [...points].sort((a, b) => a.x - b.x);

        // å°è¯•æ£€æµ‹å‡½æ•°ç±»å‹
        const xValues = sortedPoints.map((p) => p.x);
        const yValues = sortedPoints.map((p) => p.y);

        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘çº¿æ€§
        if (isApproximatelyLinear(sortedPoints)) {
          const firstPoint = sortedPoints[0];
          const lastPoint = sortedPoints[sortedPoints.length - 1];
          const slope =
            (lastPoint.y - firstPoint.y) / (lastPoint.x - firstPoint.x);
          const intercept = firstPoint.y - slope * firstPoint.x;

          if (Math.abs(intercept) < 0.01) {
            return `${slope.toFixed(2)}*x`;
          } else if (intercept > 0) {
            return `${slope.toFixed(2)}*x+${intercept.toFixed(2)}`;
          } else {
            return `${slope.toFixed(2)}*x${intercept.toFixed(2)}`;
          }
        }

        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘äºŒæ¬¡å‡½æ•°
        if (
          sortedPoints.length >= 4 &&
          isApproximatelyQuadratic(sortedPoints)
        ) {
          const quadratic = fitQuadraticApprox(sortedPoints);
          return quadratic;
        }

        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æ­£å¼¦å‡½æ•°
        if (isApproximatelySinusoidal(sortedPoints)) {
          const sinParams = fitSinusoidal(sortedPoints);
          return sinParams;
        }

        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æŒ‡æ•°å‡½æ•°
        if (isApproximatelyExponential(sortedPoints)) {
          return "æŒ‡æ•°å‡½æ•°è¿‘ä¼¼";
        }

        // é»˜è®¤è®¡ç®—æ‹‰æ ¼æœ—æ—¥æ’å€¼å¤šé¡¹å¼
        return calculateLagrangePolynomial();
      }

      // æ£€æŸ¥æ˜¯å¦æ¥è¿‘çº¿æ€§
      function isApproximatelyLinear(points) {
        if (points.length < 3) return true;

        const firstPoint = points[0];
        const lastPoint = points[points.length - 1];
        const expectedSlope =
          (lastPoint.y - firstPoint.y) / (lastPoint.x - firstPoint.x);

        let maxDeviation = 0;
        for (let i = 1; i < points.length - 1; i++) {
          const expectedY =
            firstPoint.y + expectedSlope * (points[i].x - firstPoint.x);
          const deviation = Math.abs(points[i].y - expectedY);
          maxDeviation = Math.max(maxDeviation, deviation);
        }

        const range = Math.abs(lastPoint.y - firstPoint.y);
        return maxDeviation < Math.max(0.5, range * 0.1);
      }

      // æ£€æŸ¥æ˜¯å¦æ¥è¿‘äºŒæ¬¡å‡½æ•°
      function isApproximatelyQuadratic(points) {
        if (points.length < 4) return false;

        // ä½¿ç”¨å‰ä¸‰ä¸ªç‚¹æ‹ŸåˆäºŒæ¬¡å‡½æ•°ï¼Œæ£€æŸ¥å…¶ä»–ç‚¹çš„åå·®
        const [p1, p2, p3] = points.slice(0, 3);

        const denom = (p1.x - p2.x) * (p1.x - p3.x) * (p2.x - p3.x);
        if (Math.abs(denom) < 0.001) return false;

        const a =
          (p3.x * (p2.y - p1.y) + p2.x * (p1.y - p3.y) + p1.x * (p3.y - p2.y)) /
          denom;
        const b =
          (p3.x * p3.x * (p1.y - p2.y) +
            p2.x * p2.x * (p3.y - p1.y) +
            p1.x * p1.x * (p2.y - p3.y)) /
          denom;
        const c =
          (p2.x * p3.x * (p2.x - p3.x) * p1.y +
            p3.x * p1.x * (p3.x - p1.x) * p2.y +
            p1.x * p2.x * (p1.x - p2.x) * p3.y) /
          denom;

        let maxDeviation = 0;
        for (let i = 3; i < points.length; i++) {
          const x = points[i].x;
          const expectedY = a * x * x + b * x + c;
          const deviation = Math.abs(points[i].y - expectedY);
          maxDeviation = Math.max(maxDeviation, deviation);
        }

        const yRange =
          Math.max(...points.map((p) => p.y)) -
          Math.min(...points.map((p) => p.y));
        return maxDeviation < Math.max(0.5, yRange * 0.15);
      }

      // æ‹ŸåˆäºŒæ¬¡å‡½æ•°è¿‘ä¼¼
      function fitQuadraticApprox(points) {
        const [p1, p2, p3] = points.slice(0, 3);

        const denom = (p1.x - p2.x) * (p1.x - p3.x) * (p2.x - p3.x);
        if (Math.abs(denom) < 0.001) return "x";

        const a =
          (p3.x * (p2.y - p1.y) + p2.x * (p1.y - p3.y) + p1.x * (p3.y - p2.y)) /
          denom;
        const b =
          (p3.x * p3.x * (p1.y - p2.y) +
            p2.x * p2.x * (p3.y - p1.y) +
            p1.x * p1.x * (p2.y - p3.y)) /
          denom;
        const c =
          (p2.x * p3.x * (p2.x - p3.x) * p1.y +
            p3.x * p1.x * (p3.x - p1.x) * p2.y +
            p1.x * p2.x * (p1.x - p2.x) * p3.y) /
          denom;

        let expr = "";
        if (Math.abs(a) > 0.01) {
          expr += `${a.toFixed(2)}*x^2`;
        }
        if (Math.abs(b) > 0.01) {
          if (expr && b > 0) expr += "+";
          expr += `${b.toFixed(2)}*x`;
        }
        if (Math.abs(c) > 0.01) {
          if (expr && c > 0) expr += "+";
          expr += c.toFixed(2);
        }

        return expr || "0";
      }

      // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æ­£å¼¦å‡½æ•°
      function isApproximatelySinusoidal(points) {
        if (points.length < 6) return false;

        // ç®€å•æ£€æŸ¥ï¼šçœ‹æ˜¯å¦æœ‰å‘¨æœŸæ€§æŒ¯è¡
        const yValues = points.map((p) => p.y);
        const yMean = yValues.reduce((a, b) => a + b) / yValues.length;

        let crossings = 0;
        let lastSign = yValues[0] > yMean ? 1 : -1;

        for (let i = 1; i < yValues.length; i++) {
          const currentSign = yValues[i] > yMean ? 1 : -1;
          if (currentSign !== lastSign) {
            crossings++;
            lastSign = currentSign;
          }
        }

        return crossings >= 4; // è‡³å°‘2ä¸ªå®Œæ•´å‘¨æœŸ
      }

      // æ‹Ÿåˆæ­£å¼¦å‡½æ•°
      function fitSinusoidal(points) {
        const yValues = points.map((p) => p.y);
        const amplitude = (Math.max(...yValues) - Math.min(...yValues)) / 2;
        const offset = (Math.max(...yValues) + Math.min(...yValues)) / 2;

        // ä¼°ç®—é¢‘ç‡ï¼ˆç®€åŒ–ï¼‰
        const xRange = points[points.length - 1].x - points[0].x;
        const frequency = (2 * Math.PI) / (xRange / 2); // å‡è®¾2ä¸ªå‘¨æœŸ

        if (Math.abs(offset) < 0.01) {
          return `${amplitude.toFixed(2)}*sin(${frequency.toFixed(2)}*x)`;
        } else if (offset > 0) {
          return `${amplitude.toFixed(2)}*sin(${frequency.toFixed(
            2
          )}*x)+${offset.toFixed(2)}`;
        } else {
          return `${amplitude.toFixed(2)}*sin(${frequency.toFixed(
            2
          )}*x)${offset.toFixed(2)}`;
        }
      }

      // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æŒ‡æ•°å‡½æ•°
      function isApproximatelyExponential(points) {
        if (points.length < 4) return false;

        // æ£€æŸ¥yå€¼æ˜¯å¦å‘ˆæŒ‡æ•°å¢é•¿æˆ–è¡°å‡
        const yValues = points.map((p) => p.y);
        if (yValues.some((y) => y <= 0)) return false; // æŒ‡æ•°å‡½æ•°å¿…é¡»ä¸ºæ­£

        const logYValues = yValues.map((y) => Math.log(y));
        return isApproximatelyLinear(
          points.map((p, i) => ({ x: p.x, y: logYValues[i] }))
        );
      }

      // è®¡ç®—æ‹‰æ ¼æœ—æ—¥æ’å€¼å¤šé¡¹å¼çš„å…·ä½“è¡¨è¾¾å¼
      function calculateLagrangePolynomial() {
        if (points.length === 0) return "x";
        if (points.length === 1) return points[0].y.toFixed(2);

        // åˆå§‹åŒ–å¤šé¡¹å¼ç³»æ•°æ•°ç»„ (ä»å¸¸æ•°é¡¹åˆ°æœ€é«˜æ¬¡é¡¹)
        const degree = points.length - 1;
        const coefficients = new Array(degree + 1).fill(0);

        // å¯¹æ¯ä¸ªç‚¹è®¡ç®—å…¶æ‹‰æ ¼æœ—æ—¥åŸºå‡½æ•°çš„è´¡çŒ®
        for (let i = 0; i < points.length; i++) {
          const xi = points[i].x;
          const yi = points[i].y;

          // è®¡ç®—ç¬¬iä¸ªæ‹‰æ ¼æœ—æ—¥åŸºå‡½æ•° Li(x)
          const baseCoeffs = calculateLagrangeBasis(i);

          // å°† yi * Li(x) åŠ åˆ°æ€»å¤šé¡¹å¼ä¸­
          for (let j = 0; j < baseCoeffs.length; j++) {
            coefficients[j] += yi * baseCoeffs[j];
          }
        }

        // æ ¼å¼åŒ–å¤šé¡¹å¼è¡¨è¾¾å¼
        return formatPolynomialFromCoeffs(coefficients);
      }

      // è®¡ç®—ç¬¬iä¸ªæ‹‰æ ¼æœ—æ—¥åŸºå‡½æ•°çš„ç³»æ•°
      function calculateLagrangeBasis(i) {
        const xi = points[i].x;
        const degree = points.length - 1;

        // å¼€å§‹æ—¶åŸºå‡½æ•°æ˜¯å¸¸æ•°1
        let coeffs = [1]; // è¡¨ç¤ºå¤šé¡¹å¼ 1

        // é€ä¸ªä¹˜ä»¥ (x - xj) / (xi - xj) å…¶ä¸­ j != i
        for (let j = 0; j < points.length; j++) {
          if (i !== j) {
            const xj = points[j].x;
            const denominator = xi - xj;

            if (Math.abs(denominator) < 1e-10) continue; // é¿å…é™¤é›¶

            // å°†å½“å‰å¤šé¡¹å¼ä¹˜ä»¥ (x - xj) / (xi - xj)
            coeffs = multiplyPolynomial(coeffs, [
              -xj / denominator,
              1 / denominator,
            ]);
          }
        }

        // ç¡®ä¿ç³»æ•°æ•°ç»„é•¿åº¦æ­£ç¡®
        while (coeffs.length <= degree) {
          coeffs.push(0);
        }

        return coeffs;
      }

      // å¤šé¡¹å¼ä¹˜æ³•ï¼šå°†ä¸¤ä¸ªå¤šé¡¹å¼ç›¸ä¹˜
      function multiplyPolynomial(poly1, poly2) {
        const result = new Array(poly1.length + poly2.length - 1).fill(0);

        for (let i = 0; i < poly1.length; i++) {
          for (let j = 0; j < poly2.length; j++) {
            result[i + j] += poly1[i] * poly2[j];
          }
        }

        return result;
      }

      // æ ¼å¼åŒ–å¤šé¡¹å¼ç³»æ•°ä¸ºè¡¨è¾¾å¼
      function formatPolynomialFromCoeffs(coeffs) {
        let expr = "";

        // ä»æœ€é«˜æ¬¡é¡¹å¼€å§‹
        for (let i = coeffs.length - 1; i >= 0; i--) {
          const coeff = coeffs[i];

          // è·³è¿‡æ¥è¿‘é›¶çš„ç³»æ•°
          if (Math.abs(coeff) < 0.001) continue;

          // æ·»åŠ ç¬¦å·
          if (expr.length > 0) {
            expr += coeff > 0 ? "+" : "";
          }

          // æ ¼å¼åŒ–ç³»æ•°å’Œå˜é‡
          if (i === 0) {
            // å¸¸æ•°é¡¹
            expr += coeff.toFixed(2);
          } else if (i === 1) {
            // ä¸€æ¬¡é¡¹
            if (Math.abs(coeff - 1) < 0.001) {
              expr += "x";
            } else if (Math.abs(coeff + 1) < 0.001) {
              expr += "-x";
            } else {
              expr += `${coeff.toFixed(2)}*x`;
            }
          } else {
            // é«˜æ¬¡é¡¹
            if (Math.abs(coeff - 1) < 0.001) {
              expr += `x^${i}`;
            } else if (Math.abs(coeff + 1) < 0.001) {
              expr += `-x^${i}`;
            } else {
              expr += `${coeff.toFixed(2)}*x^${i}`;
            }
          }
        }

        return expr || "0";
      }

      // æ›´æ–°å‡½æ•°æ˜¾ç¤º
      function updateFunctionDisplay() {
        currentFunction = generateFunctionExpression();
        currentFunctionDisplay.textContent = `f(x) = ${currentFunction}`;
      }

      // åƒç´ åæ ‡è½¬æ•°å­¦åæ ‡
      function pixelToMath(pixelX, pixelY) {
        return {
          x: (pixelX - centerX) / scale,
          y: (centerY - pixelY) / scale,
        };
      }

      // æ•°å­¦åæ ‡è½¬åƒç´ åæ ‡
      function mathToPixel(mathX, mathY) {
        return {
          x: centerX + mathX * scale,
          y: centerY - mathY * scale,
        };
      }

      // æŸ¥æ‰¾ç‚¹å‡»çš„ç‚¹
      function findPointAt(pixelX, pixelY) {
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          const pixel = mathToPixel(point.x, point.y);
          const distance = Math.sqrt(
            (pixelX - pixel.x) ** 2 + (pixelY - pixel.y) ** 2
          );
          if (distance <= 8) {
            return i;
          }
        }
        return -1;
      }

      // ç”»å¸ƒäº‹ä»¶å¤„ç†
      functionCanvas.addEventListener("mousedown", (e) => {
        const rect = functionCanvas.getBoundingClientRect();
        const pixelX = e.clientX - rect.left;
        const pixelY = e.clientY - rect.top;

        const pointIndex = findPointAt(pixelX, pixelY);

        if (e.button === 2) {
          // å³é”®åˆ é™¤ç‚¹
          if (pointIndex !== -1) {
            points.splice(pointIndex, 1);
            updateFunctionDisplay();
            drawCanvas();
          }
          e.preventDefault();
          return;
        }

        if (pointIndex !== -1) {
          // å¼€å§‹æ‹–æ‹½
          draggedPoint = pointIndex;
        } else {
          // æ·»åŠ æ–°ç‚¹
          const mathCoord = pixelToMath(pixelX, pixelY);
          points.push({
            x: Math.round(mathCoord.x),
            y: Math.round(mathCoord.y),
          });
          updateFunctionDisplay();
          drawCanvas();
        }
      });

      functionCanvas.addEventListener("mousemove", (e) => {
        const rect = functionCanvas.getBoundingClientRect();
        const pixelX = e.clientX - rect.left;
        const pixelY = e.clientY - rect.top;

        if (draggedPoint !== null) {
          const mathCoord = pixelToMath(pixelX, pixelY);
          points[draggedPoint] = {
            x: Math.round(mathCoord.x),
            y: Math.round(mathCoord.y),
          };
          updateFunctionDisplay();
          drawCanvas();
        }

        // æ˜¾ç¤ºåæ ‡ä¿¡æ¯
        const mathCoord = pixelToMath(pixelX, pixelY);
        pointInfo.textContent = `(${mathCoord.x.toFixed(
          0
        )}, ${mathCoord.y.toFixed(0)})`;
        pointInfo.style.left = e.clientX + 10 + "px";
        pointInfo.style.top = e.clientY - 30 + "px";
        pointInfo.style.display = "block";
      });

      functionCanvas.addEventListener("mouseup", () => {
        draggedPoint = null;
      });

      functionCanvas.addEventListener("mouseleave", () => {
        draggedPoint = null;
        pointInfo.style.display = "none";
      });

      functionCanvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      // æ§åˆ¶æŒ‰é’®äº‹ä»¶
      clearPointsBtn.addEventListener("click", () => {
        points = [];
        updateFunctionDisplay();
        drawCanvas();
      });

      resetViewBtn.addEventListener("click", () => {
        points = [];
        currentFunction = "x";
        updateFunctionDisplay();
        drawCanvas();
      });

      applyFunctionBtn.addEventListener("click", () => {
        mathFunctionInput.value = currentFunction;
        closeFunctionEditorModal();
      });

      // ç¼–è¾‘å™¨äº‹ä»¶ç›‘å¬
      editFunctionBtn.addEventListener("click", openFunctionEditor);
      closeFunctionEditor.addEventListener("click", closeFunctionEditorModal);

      // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
      functionEditorModal.addEventListener("click", (e) => {
        if (e.target === functionEditorModal) {
          closeFunctionEditorModal();
        }
      });
    </script>
  </body>
</html>
